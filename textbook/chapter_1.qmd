---
title: "Intro to data visualization and graphical grammars"
include-in-header:
  - text: |
      <style>
        .table.dataframe {
          width: auto;
          text-align: right;
        }
      </style>
fig-width: 4
fig-height: 4
---

```{python setup}
#| echo: false
#| output: false

import pandas as pd
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri


pd.set_option('display.max_rows', 6)

def show_df(df):
    if isinstance(df, ro.vectors.DataFrame):
        with (ro.default_converter + pandas2ri.converter).context():
            df = ro.conversion.get_conversion().rpy2py(df)
    return HTML(df._repr_html_())
```

::: {.callout-note title="Learning outcomes"}
- **Explain** that the main advantage of visualizing data instead of presenting it with numbers is that they are easier to interpret for humans.

- **Understand** that the advantage of using a high level level visualization syntax is that it allows us to think in terms of the data, rather than focusing on graphical details.

- **Explain** how a grammar of graphics defines grammatical rules that can be used to construct entire visualizations from smaller building blocks.

- **Apply** the visualization grammars in Altair and ggplot to create a basic chart via `alt.Chart().mark_point().encode(x='...', y='...', color='...')` and <br> `ggplot() + aes(x=..., y=..., color=...) + geom_point()`

:::

## What is data visualization?

At its core,
data visualization is about representing numbers with graphical elements
such as the position of a point, the length of a bar, or the color of a line.

## What is the purpose of visualizing data?

We can use visualizations both to improve own understanding of data
and to effectively communicate our data insights to others.
While we often use visualization
to help us answer a specific question
we have about our dataset,
it can also help us generate new questions.

## Why bother visualizing data instead of showing raw numbers?

To understand why visualizations are so powerful,
it is helpful to remember that to answer a question,
we often have to put the data in a format that is easy for us humans to interpret.
Because our number systems have only been around for about 5,000 years,
we need to assert effort and train ourselves
to recognize structure in numerical data.

Visual systems,
on the other hand,
have undergone refinement during 500,000,000 years of evolution,
so we can instinctively recognize visual patterns
and accurately estimate visual properties
such as colours and distances.

Practically,
this means that we can arrive at correct conclusions faster
from studying visual rather than numerical
representations of the same data.
For example, have a look at the
four sets of numbers in the table on the slide.
Can you see the differences in the general trends between these four sets of numbers?
This is a slightly modified version of the original,
<a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet" target="_blank">which was put together by statistician Francis Anscombe in the
70s.</a>

```{python}
#| echo: false

import altair as alt
import pandas as pd
from vega_datasets import data
from IPython.display import HTML

anscombe = data.anscombe()
anscombe['Set'] = anscombe['Series'].map({'I': 'A', 'II': 'B', 'III': 'C', 'IV': 'D'})
anscombe = anscombe.drop(columns='Series')
anscombe.loc[anscombe['Y'] == anscombe['Y'].max(), 'Y'] = 8.5

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s = s + (
        df
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

HTML(html_content)
```

### Summary statistics don't tell the whole story

You are likely not able to see much difference between the data sets
in the table above.
What about if I showed you a few commonly used numerical summaries of the data?

```{python}
#| echo: false

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s += (
        df
        .agg(['mean', 'std'])
        .round(2)
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
        .replace('>7.11',  ' style="background-color:#4853a4; color:#ffffff"> <b>7.11</b>')
        .replace('>1.15',  ' style="background-color:#4853a4; color:#ffffff"> <b>1.15</b>')
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

HTML(html_content)
```

<br>
Summaries,
such as the mean and standard deviation,
are helpful statistical tools
that are often useful for detecting the differences between datasets.
However,
since they collapse the data into just a few numbers,
statistical summaries can't tell the whole story about the data
and there can be important differences between datasets
that summaries fail to reveal.

Above,
the mean and standard deviation indicate that set C
is slightly different from the other sets of data
in terms of the centre of the sample distribution and the spread of that distribution,
while the remaining three sets of data have a similar centre and spread.

### Plotting the data immediately reveals patterns in the data 

So if you can't really see any patterns in the data
and the statistical summaries are the same,
that must mean that the four sets are pretty similar, right?
Sounds about right to me so let's go ahead and plot them to have a quick look and...

```{python}
#| echo: false

alt.Chart(anscombe).mark_circle(size=80, opacity=1).encode(
    x='X',
    y='Y'
).properties(
  width=300,
  height=200
).facet(
  'Set',
  columns=2
).configure_axis(
  grid=True
).configure_header(
  title=None
)
```

... what... how can they be so different... there must be something wrong, right?
Well what is wrong is that humans are not good at detecting patterns in raw numbers,
and we don't have good intuition about which combination of numbers
can contribute to the same statistical summaries.
But guess what we excel at? Detecting visual patterns!

It is immediately clear to us how these sets of numbers differ
once they are shown as graphical objects 
instead of textual objects.
We could not detect these patterns from only looking at the raw numbers or summary statistics
This is one of the main reasons why data visualization
is such a powerful tool for data exploration and communication.

In our example above,
we would come to widely different conclusions about the behaviour of the data
for the four different data sets.
Sets A and C are roughly linearly increasing at similar rates,
whereas set B reaches a plateau and starts to drop,
and set D has a constant X-value for all numbers except one big outlier.

### A modern take on Anscombe's quartet

For a more recent and dynamic illustration
of how graphical representations are much easier for us to interpret,
check out the [Datasaurus Dozen animation](https://www.autodesk.com/research/publications/same-stats-different-graphs) below.
It displays several different datasets,
all with the same mean, standard deviation and correlation between X and Y,
but looking at the data graphically shows us how different these datasets actually are.

<figure>
  <img src="https://blog.revolutionanalytics.com/downloads/DataSaurus%20Dozen.gif" alt="Datasaurus Dozen Animation" style="width:100%; max-width:600px;">
  <figcaption>The Datasaurus Dozen: Datasets with identical summary statistics but very different distributions.</figcaption>
</figure>

Now that we have experienced the benefits of visualizing data,
let's figure out how to create such visualizations!

## Which visualization library should we pick? 

There is a lot we can learn about visualization
without using coding,
but in order to make this learning experience interactive,
we will create charts programmatically
as we learn about new visualization concepts.

In order to do so,
we will start by selecting which visualization library to use.
To make an informed decision,
it is helpful to understand
that most visualization libraries can be classified as
taking either a high level declarative approach
or a low level imperative approach to creating visualization.

:::: {.callout-note icon="false"}

## Exercise

To understand the difference between these two approaches,
let's start with an example,
using the following small toy data set:


```{python}
#| echo: false

df = pd.DataFrame({
    'x': [0.2, 0.6, 1.2, 2.4],
    'y': [0.6, 0.9, 1.8, 2.7],
    'group': ['a', 'a', 'b', 'b']
})
show_df(df)
```

A helpful way to illustrate the difference
between the two syntax approaches
is to imagine that we want to create a chart
where we color the points according to their group.
Here is pseudocode^["pseudocode" is an informal way of writing code that is often used to explain a concept to the reader]
that illustrates this difference:

::: {.panel-tabset}

### Declarative syntax

```python
create_chart(
    x='x',
    y='y',
    color='group'
)
```


```{python}
#| echo: false

alt.Chart(df, width=200, height=200).mark_point().encode(
    x='x',
    y='y',
    color='group'
)
```


### Imperative syntax

```python
fig = create_figure()
colors = ['blue', 'yellow']
for color, group in zip(colors, df['group'].unique()):
    tmp_df = df[df['group'] == group]
    fig.add_chart(tmp_df['x'], tmp_df['y'], label=group, color=color)
```

```{python}
#| echo: false

alt.Chart(df, width=200, height=200).mark_point().encode(
    x='x',
    y='y',
    color='group'
)
```

:::

Although the same chart is created from both these pseudocode examples,
the syntax looks widely different.
Before clicking on the solution below to read our explanation of the two approaches,
pause here and try to describe the differences between the two
in your own words^[Actively engaging your brain in exercises like this
instead of simply trying to memorize an explanation you read,
aids in recalling the information later].
 <!--TODO ref? -->

::: {.callout-tip title='Solution' collapse=true}

Based on the syntax of the exercise above,
we can say that a declarative approach to visualization
let's us express ourselves in terms of the data (`color='group'`)
whereas an imperative approach to visualization focuses more explicitly
on plot construction details such as defining colors explicitly
and then assigning them to groups by looping through the data.

:::

::::

A related way to understand declarative vs imperative approaches
is to consider the difference between giving an instruction in each:

::: {.panel-tabset}

### Declarative instruction

**"Color by the column `group` in the dataframe."**

**Focus**: Declaring links between data variables (e.g., `group`) and graphical properties (e.g. `color`). The rest of the plot details (such as which colors to use) are handled automatically.

### Imperative instruction

**"Loop over the dataframe and plot any observations of group `A` in blue and any observations of group `B` in yellow."**

**Focus**: Being explicit with all the details for creating the chart via for-loops and low-level drawing commands.
:::

In this book we will learn about
declarative visualization tools,
since these allow us to code a high-level specification
of *what* we want the visualization to include,
rather than coding out the details of *how* to implement the visualization.
Another way to state this would be that high level libraries
focus on **data and relationships**,
whereas low level libraries focus on **plot construction details.**
<!--TODO explain jargon delcariative/imperative? -->

Among declarative visualization libraries,
there are still a few different approaches
to how visualization is created.
Here,
we are going to learn about libraries that implement
a so called "grammar of graphics".

## What is a grammar of graphics?

A graphical grammar is a system for creating visualizations
by combining basic elements according to specific rules.
It parallels the grammars of natural and programming languages,
but applies to visual components.

We are all familiar with the grammatical rules for natural languages^[
What you typically think of as "a language": English, Mandarin, Hindi, Swedish, etc],
where they tell us how to combine words into sentences
to convey particular meanings.
Programming languages also have a grammatical structure,
let's see how they work in the following exercise:

:::: {.callout-note icon="false"}

## Exercise

What do you think the output would be of the following Python code?


```python
1 + 2
```

As you might have expected,
the output is `3`
because Python uses the conventional rules of mathematics
to add the two numbers together.
Almost all programming languages follow this rule.
But what does the `+`-operator do
if we are trying to add something other than numbers.
What do you think the output would be of the following code?
Do you think it differs between programming languages?

```python
'one' + 'two'
```
::: {.callout-tip collapse=true}

### Solution

<!-- TODO `` -->
The grammar of Python defines that the `+`-operator
should perform concatenation when strings are added together,
so the returned result would be `"onetwo"`.
In contrast,
the grammar of R says that there is no such thing as addition of strings,
so it would throw an error complaining that non-numeric arguments were passed to the `+`-operator.

:::

::::

As with the grammar of programming languages,
visualization packages make different choices
for what happens when different visual elements are added together.
Key components of a graphical grammar often include:

1. **Canvas**: The background or base of the chart.
2. **Geometric marks**: Visual elements representing data (e.g. points, bars).
3. **Visual encoding**: Rules for mapping data to visual properties (e.g. the column `'group'` to `color`).

In the next session,
we will see how these components can be added together using code.

The following table illustrates the similarities between the grammars of programming, natural language and graphics:

| Component    | Natural Language        | Programming Language    | Graphical Grammar                             |
|--------------|-------------------------|-------------------------|-----------------------------------------------|
| Basic Units  | Words                   | Variables, literals     | Marks (points, lines, bars)                   |
| Syntax Rules | Word order, punctuation | Syntax rules, operators | Rules for combining marks, layers, aesthetics |
| Semantics    | Word meanings, context  | Expression meanings     | Meanings of visual encodings                  |
| Composition  | Sentences, paragraphs   | Statements, code blocks | Layers, facets                                |
| Output       | Text                    | Executable code         | Data visualizations                           |
| Modifiers    | Adjectives, adverbs     | Attributes, parameters  | Scales, legends, annotations                  |

Understanding these parallels enables users to approach data visualization systematically,
leveraging a defined set of components and rules.

## Learning to speak with a grammar of graphics

To start creating our own charts,
we will work with two libraries that implement a grammar of graphics:
Altair in Python, and ggplot in R.
These two libraries both offer a powerful and concise visualization grammar
for quickly building a wide range of statistical charts.

What does these grammars look like?
In brief,
we first create a canvas/chart,
then encode our data variables as different channels in this chart (x, y, color, etc)
and add geometric marks to represent the data (points, lines, etc).
You can see an illustration of this in the image below,
together with how ggplot (top) and Altair (bottom) implements the grammatical components in their respective syntax.
The exact syntax is slightly different, but the overall structure very much the same.

![](/img/grammar-of-graphics.jpeg)

<!--TODO Ideally remake this images using `+ aes()` instead -->
<!--TODO Should I maybe replace it wirh a programmatic version? It is a fun image, not sure if it looks to informal -->

<!-- Coding with grammar in Altair and ggplot -->

**Let's get coding**


Let's get coding!

Data in Altair and ggplot is built around ["tidy"](http://vita.had.co.nz/papers/tidy-data.html) dataframes,
which consists of a set of named data *columns* (also referred to as *variables* or *fields*)
with one feature each
and rows with one observation each.
Here,
we will load in a small dataset relating to cars
containing historical trends in automotive design, performance, and efficiency.

:::: {.panel-tabset}

## Altair

```{python}
#| output: false
import altair as alt
import pandas as pd


url = 'https://raw.githubusercontent.com/joelostblom/teaching-datasets/main/cars.csv'
cars = pd.read_csv(url)
cars
```

```{python}
#| echo: false
show_df(cars)
```

::: {.column-margin}

**Stellar Charts**

Altair is the name of a star in the same constellation as the star Vega, which is also the name of the Javascript library that Altair is built upon.

![](https://upload.wikimedia.org/wikipedia/commons/6/69/Altair.jpg)

:::

## ggplot

```{r}
#| echo: false
#| output: false
suppressPackageStartupMessages(library(tidyverse))
```

```{r}
#| output: false
library(tidyverse)

url = 'https://raw.githubusercontent.com/joelostblom/teaching-datasets/main/cars.csv'
cars = read_csv(url, show_col_types = FALSE)
cars
```

```{python}
#| echo: false
show_df(ro.r['cars'])
```

::: {.column-margin}

**Grammatically correct**

The "gg" in ggplot is a reference to the book "Grammar of Graphics",
which inspired the creation of the ggplot library.

![](https://pictures.abebooks.com/isbn/9780387987743-us.jpg)

:::

::::

The fundamental object in Altair is the `Chart`, which takes a data frame as a single argument `alt.Chart(cars)`.

With a chart object in hand, we can now specify how we would like the data to be visualized. We first indicate what kind of geometric *mark* we want to use to represent the data. We can set the `mark` attribute of the chart object using the the `Chart.mark_*` methods.

For example, we can show the data as a point using `mark_point()`:


```{python}
alt.Chart(cars).mark_point()
```


Here the rendering consists of one point per row in the dataset, all plotted on top of each other, since we have not yet specified positions for these points.

To visually separate the points, we can map various *encoding channels*, or *channels* for short, to fields in the dataset. For example, we could *encode* the field `Miles_per_Gallon` of the data using the `x` channel, which represents the x-axis position of the points. To specify this, use the `encode` method:


::: {.panel-tabset}

## Altair
```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon'
)
```

## ggplot


```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y=0)) +
  geom_point()
```

::: {.column-margin}

<br>
<br>

In ggplot2, you begin by creating a plot object with your dataset, such as `ggplot(cars)`. This is similar to Altair's `Chart(cars)`. To visualize the data, you add a geometric object like `geom_point()`, which is conceptually equivalent to Altair's `mark_point()`. Initially, this would plot all points at the origin. To meaningfully represent the data, you map variables to visual properties using `aes()`. For instance, to plot Miles per Gallon on the x-axis, you'd use `aes(x = Miles_per_Gallon)` within `geom_point()`. This corresponds to Altair's `encode` method. 
:::

:::

The `encode()` method builds a key-value mapping between encoding channels (such as `x`, `y`, `color`, `shape`, `size`, *etc.*) to fields in the dataset, accessed by field name. For Pandas data frames, Altair automatically determines an appropriate data type for the mapped column, which in this case is the *nominal* type, indicating unordered, categorical values.




You can also see that there is a button with three dots
to the top right.
If you click this you will have options to save the chart
and to open the underlying Vega-Lite code.

Though we've now separated the data by one attribute, we still have multiple points overlapping within each category. Let's further separate these by adding a `y` encoding channel;
for example lets say we wanted to answer the question:
"How is a cars fuel efficiency related to its horsepower?"

::: {.panel-tabset}

## Altair

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower'
)
```

## ggplot

```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y = Horsepower)) +
    geom_point()
```

::: {.column-margin}

<br>
<br>
The default ggplot style is quite different from that of Altair.
Both have advantages,
and they are easy to customize to look however you want,
which we will also get into later.
Note that ggplot does not including the origin of the plot (x=0, y=0) by default,
but Altair does for many cases.
Both these defaults are sensible in different context,
which we will learn more about in later chapters.

:::
::: 

Here we can see that there seems to be a negative correlation with Horsepower and Miles_per_Gallon:
More powerful cars consume more gas.

But there might be other variables that also influence this relationship,
e.g. the weight of the car probably matters for fuel efficiency,
since more force is needed to propel a bigger mass.
We can add more dimensions to this chart,
e.g. specifying which column we want to color the points by
and Altair will automatically figure out an appropriate colorscale to use.


::: {.panel-tabset}

# Altair
```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Weight_in_lbs'
)
```

# ggplot

```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y = Horsepower, color = Weight_in_lbs)) +
    geom_point()
    
```

::: {.column-margin}
<br>
<br>
As with Altair,
ggplot chooses an appropriate continuous color scale for the quantitative data,
although it start from dark instead of light,
which could be related to the different choice of background color.
Notice also the difference in how the legend is added,
in Altair the overall width of the figure was increased,
whereas here the legend takes part of the figure width from the canvas,
which is made narrower.
:::

:::

Aha! Here we can see that weight is also correlated with Horsepower (positively)
and Miles_per_Gallon (negatively).
We can't say anything about causation from the plot alone,
just correlation.

One of the really neat things with Altair is that it extends its grammar 
to interactive plot elements as well.
We will see much more of this later in the book.
Let's add a tooltip to each data point with the name of the car,
hover over the data points to see the tooltip show up!


```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    tooltip='Name'
)
```


## Mission

Your name is **Zephyr Eco-Luna** and you have been tasked with investigating emissions in the city of Viridia. With a commitment to sustainability and a vision for a greener future, Viridia is taking proactive steps to investigate and mitigate its environmental impact. One significant area of focus is the emissions associated with food consumption and production.


```{=html}
<br>

        <div class="ministry-id-card">
            <div class="accent-line"></div>
            <div class="left-column">
                <div class="logo">Ministry of Environment</div>
                <div class="name">Zephyr Eco-Luna</div>
                <div class="info">
                    <div class="info-item">
                        <span class="label">Position</span>
                        <span class="value">Emissions Investigator</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Department</span>
                        <span class="value">Urban Food Systems</span>
                    </div>
                    <div class="info-item">
                        <span class="label">ID Number</span>
                        <span class="value">EI-2024-0042</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Clearance</span>
                        <span class="value">Level 3</span>
                    </div>
                </div>
                <div class="footer">Protecting Our Future â€¢ Est. 2024</div>
            </div>
            <div class="right-column">
                <img src="/img/zephyr.jpg" alt="Avatar" class="avatar">
            </div>
        </div>
<br>
```

To start with your investigation, youâ€™ll need to visualize the emissions data effectively. This will help unlock insights crucial for the Ministry of Environment.


```{python}
import pandas as pd
df_food = pd.read_csv("data/aggregated__food_data.csv")

df_food
```

<img src="/img/environ_minister.jpg" alt="Avatar" class="avatar" style="display: none;">

### Exercise 1: Planning your analysis

Before you start, your boss **Minister Reed** has a few questions for you...

```{ojs}
//| echo: false
{
    
const apiUrl = "https://openaiproxy-621feba224c9.herokuapp.com/api/proxy";

const instructions = "You are Minister Reed of the city of Viridia, a sharp-witted, impatient but supportive environmental minister. Your colleague Zephyr has been tasked with creating an Emissions Report. Guide Zephyr toward understanding why a complete picture is necessary and why including the Total Food Supply (kg/capita/yr) column matters (alongside the Emissions Kg CO2 / kg product). Once you get a satisfactory answer, end the conversation immediately. You are in a phone text convo.";

const first_message = "Zephyr, I need your Emissions Report on my desk by 2pm. Remind me why you are including the Total Food Supply in your analysis?";

let messageCount = 0;

// Initialize messages array with system instructions and initial message
let messages = [
  { role: "system", content: instructions },
  { role: "assistant", content: first_message }
];

async function sendOpenAIRequest(prompt) {
  try {
    // Add user message to conversation history
    messages.push({ role: "user", content: prompt });

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: "gpt-4o",
        messages: messages,
        temperature: 1,
        max_tokens: 100,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    const assistantResponse = data.choices[0].message.content;

    // Add assistant's response to conversation history
    messages.push({ role: "assistant", content: assistantResponse });

    return assistantResponse;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

const container = html`<div id="chat-container">
  <div class="highlight-line"></div>
  <div id="chat-display"></div>
  <textarea id="user-input" placeholder="Enter your message here"></textarea>
  <button id="submit-button">Send Message</button>
</div>`;

const chatDisplay = container.querySelector('#chat-display');
const userInput = container.querySelector('#user-input');
const submitButton = container.querySelector('#submit-button');

function createChatMessageHTML(content, isBoss) {
  return html`
    <div class="chat-message ${isBoss ? 'boss-message' : ''}">
      <div class="chat-avatar" style="background-image: url('${isBoss ? '/img/environ_minister.jpg' : '/img/zephyr.jpg'}')"></div>
      <div class="chat-message-content">
        <div class="chat-sender-name">${isBoss ? 'Minister Reed' : 'Zephyr Eco-Luna'}</div>
        <div>${content}</div>
      </div>
    </div>
  `;
}

// Initial message
chatDisplay.appendChild(createChatMessageHTML(first_message, true));

submitButton.onclick = async () => {
  const prompt = userInput.value;
  if (prompt.trim() === '') return;

  messageCount++;

  // Display user's message
  chatDisplay.appendChild(createChatMessageHTML(prompt, false));
  userInput.value = '';
  chatDisplay.scrollTop = chatDisplay.scrollHeight;

  try {
    const response = await sendOpenAIRequest(prompt);
    chatDisplay.appendChild(createChatMessageHTML(response, true));
  } catch (error) {
    chatDisplay.appendChild(createChatMessageHTML("Error: " + error.message, true));
  }

  // Scroll to the bottom of the chat display
  chatDisplay.scrollTop = chatDisplay.scrollHeight;
};

chatDisplay.scrollTop = chatDisplay.scrollHeight;

return html`${container}`;
}
```


### Exercise 2: Visualizing the data

It's time to put the Grammar of Graphics to good use. Create a scatterplot chart of the food supply and emissions data by following these steps:

1. Instantiate the chart from the `df_food` dataframe
2. Choose an appropriate graphical `mark_*()`
3. Map `Total Food Supply (kg/capita/yr)` and `Emissions (Kg CO2 / kg product)` to visual encoding channels


::: {.callout-tip icon="false" collapse="true"}

# Solution

```{python}

alt.Chart(df_food).mark_point().encode(
    x='Total Food Supply (kg/capita/yr)',
    y='Emissions (Kg CO2 / kg product)',
    tooltip='Food Item'
)
```

:::

### Exercise 3: Inspecting individual marks

These are striking results! There are some clear clusters and outliers in the data. Add a tooltip to your chart to investigate which foods these are.

### Exercise 4: Reporting your results

```{ojs}
//| echo: false
{
  const apiUrl = "https://openaiproxy-621feba224c9.herokuapp.com/api/proxy";
  const instructions = "You are Minister Reed of the city of Viridia, a sharp witted, impatient but supportive environmental minister. You are talking with your colleague Zephyr who has been tasked with creating an Emissions Report. Don't give solution in first message, but you must provide it after 3 messages and end the conversation definitively when you do. The report found shocking findings: beef Emissions Kg CO2 / kg product are incredibly high (around 60) compared to other food and supply is also high for it. Another is milk, which has Total Food Supply of around 190 (kg/capita/yr) and moderate emissions. The exciting part is that many vegetables etc have extremely low emissions. You see HUGE potential in reducing beef consumption in Viridia given the climate disaster)";
  const first_message = "Zephyr, I've been waiting! What patterns did you see in the food emissions data?";
  let messageCount = 0;

  let messages = [
    { role: "system", content: instructions },
    { role: "assistant", content: first_message }
  ];

  async function sendOpenAIRequest(prompt) {
    try {
      messages.push({ role: "user", content: prompt });

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: messages,
          temperature: 1,
          max_tokens: 100,
          top_p: 1,
          frequency_penalty: 0,
          presence_penalty: 0
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      const assistantResponse = data.choices[0].message.content;
      messages.push({ role: "assistant", content: assistantResponse });

      return assistantResponse;
    } catch (error) {
      console.error("Error:", error);
      throw error;
    }
  }

  const container = html`<div id="chat-container">
    <div class="highlight-line"></div>
    <div id="chat-display"></div>
    <textarea id="user-input" placeholder="Enter your message here"></textarea>
    <button id="submit-button">Send Message</button>
  </div>`;

  const chatDisplay = container.querySelector('#chat-display');
  const userInput = container.querySelector('#user-input');
  const submitButton = container.querySelector('#submit-button');

  function createChatMessageHTML(content, isBoss) {
    return html`
      <div class="chat-message ${isBoss ? 'boss-message' : ''}">
        <div class="chat-avatar" style="background-image: url('${isBoss ? '/img/environ_minister.jpg' : '/img/zephyr.jpg'}')"></div>
        <div class="chat-message-content">
          <div class="chat-sender-name">${isBoss ? 'Minister Reed' : 'Zephyr Eco-Luna'}</div>
          <div>${content}</div>
        </div>
      </div>
    `;
  }

  // Initial message
  chatDisplay.appendChild(createChatMessageHTML(first_message, true));

  submitButton.onclick = async () => {
    const prompt = userInput.value;
    if (prompt.trim() === '') return;
    messageCount++;
    chatDisplay.appendChild(createChatMessageHTML(prompt, false));
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
    userInput.value = '';
    try {
      const response = await sendOpenAIRequest(prompt);
      chatDisplay.appendChild(createChatMessageHTML(response, true));
    } catch (error) {
      chatDisplay.appendChild(createChatMessageHTML("Error: " + error.message, true));
    }
    // Scroll to the bottom of the chat display
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  };

  chatDisplay.scrollTop = chatDisplay.scrollHeight;

  return html`${container}`;
}
```

```{=html}
<div class="song-container">
  <div class="song-details">
    <div class="song-icon">ðŸŽµ</div>
    <div class="song-info">
      <div class="song-title">Data Viz Ecosystem</div>
      <div class="song-artist">Generated with artificial intelligence</div>
    </div>
  </div>
  <div class="audio-player">
    <audio controls>
    <source src="/audio/data-viz-ecosystem.mp3" type="audio/mpeg"></source>
    Your browser does not support the audio element.
    </audio>
  </div>
</div>
```