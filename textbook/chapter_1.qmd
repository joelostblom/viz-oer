---
title: "Intro to data visualization and graphical grammars"
include-in-header:
  - text: |
      <style>
        .table.dataframe {
          width: auto;
          text-align: right;
        }
      </style>
fig-width: 4
fig-height: 4
---

```{python setup}
#| echo: false
#| output: false

import pandas as pd
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri


pd.set_option('display.max_rows', 6)

def show_df(df):
    if isinstance(df, ro.vectors.DataFrame):
        with (ro.default_converter + pandas2ri.converter).context():
            df = ro.conversion.get_conversion().rpy2py(df)
    return HTML(df._repr_html_())
```

::: {.callout-note title="Learning outcomes"}
- **Explain** that the main advantage of visualizing data instead of presenting it with numbers is that they are easier to interpret for humans.

- **Understand** that the advantage of using a high level level visualization syntax is that it allows us to think in terms of the data, rather than focusing on graphical details.

- **Explain** how a grammar of graphics defines grammatical rules that can be used to construct entire visualizations from smaller building blocks.

- **Apply** the visualization grammars in Altair and ggplot to create a basic chart via `alt.Chart().mark_point().encode(x='...', y='...', color='...')` and <br> `ggplot() + aes(x=..., y=..., color=...) + geom_point()`

:::

## What is data visualization?

At its core,
data visualization is about representing numbers with graphical elements
such as the position of a point, the length of a bar, or the color of a line.

## What is the purpose of visualizing data?

We can use visualizations both to improve own understanding of data
and to effectively communicate our data insights to others.
While we often use visualization
to help us answer a specific question
we have about our dataset,
it can also help us generate new questions.

## Why bother visualizing data instead of showing raw numbers?

To understand why visualizations are so powerful,
it is helpful to remember that to answer a question,
we often have to put the data in a format that is easy for us humans to interpret.
Because our number systems have only been around for about 5,000 years,
we need to assert effort and train ourselves
to recognize structure in numerical data.

Visual systems,
on the other hand,
have undergone refinement during 500,000,000 years of evolution,
so we can instinctively recognize visual patterns
and accurately estimate visual properties
such as colours and distances.

Practically,
this means that we can arrive at correct conclusions faster
from studying visual rather than numerical
representations of the same data.
For example, have a look at the
four sets of numbers in the table on the slide.
Can you see the differences in the general trends between these four sets of numbers?
This is a slightly modified version of the original,
<a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet" target="_blank">which was put together by statistician Francis Anscombe in the
70s.</a>


```{python}
#| echo: false

import altair as alt
import pandas as pd
from vega_datasets import data
from IPython.display import HTML

anscombe = data.anscombe()
anscombe['Set'] = anscombe['Series'].map({'I': 'A', 'II': 'B', 'III': 'C', 'IV': 'D'})
anscombe = anscombe.drop(columns='Series')
anscombe.loc[anscombe['Y'] == anscombe['Y'].max(), 'Y'] = 8.5

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s = s + (
        df
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

HTML(html_content)
```

### Summary statistics don't tell the whole story

You are likely not able to see much difference between the data sets
in the table above.
What about if I showed you a few commonly used numerical summaries of the data?

```{python}
#| echo: false

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s += (
        df
        .agg(['mean', 'std'])
        .round(2)
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
        .replace('>7.11',  ' style="background-color:#4853a4; color:#ffffff"> <b>7.11</b>')
        .replace('>1.15',  ' style="background-color:#4853a4; color:#ffffff"> <b>1.15</b>')
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

HTML(html_content)
```

<br>
Summaries,
such as the mean and standard deviation,
are helpful statistical tools
that are often useful for detecting the differences between datasets.
However,
since they collapse the data into just a few numbers,
statistical summaries can't tell the whole story about the data
and there can be important differences between datasets
that summaries fail to reveal.

Below,
the mean and standard deviation indicate that set C
is slightly different from the other sets of data
in terms of the centre of the sample distribution and the spread of that distribution,
while the remaining three sets of data have a similar centre and spread.

### Plotting the data immediately reveals patterns in the data 

So if you can't really see any patterns in the data
and the statistical summaries are the same,
that must mean that the four sets are pretty similar, right?
Sounds about right to me so let's go ahead and plot them to have a quick look and...

```{python}
#| echo: false

alt.Chart(anscombe).mark_circle(size=80, opacity=1).encode(
    x='X',
    y='Y'
).properties(
  width=300,
  height=200
).facet(
  'Set',
  columns=2
).configure_axis(
  grid=True
).configure_header(
  title=None
)
```

... what the... how... there must be something wrong, right?
Well what is wrong is that humans are not good at detecting patterns in raw numbers,
and we don't have good intuition about which combination of numbers can contribute to the same statistical summaries.
But guess what we excel at? Detecting visual patterns!

It is immediately clear to us how these sets of numbers differ
once they are shown as graphical objects 
instead of textual objects.
We could not detect these patterns from only looking at the raw numbers or summary statistics
This is one of the main reasons why data visualization
is such a powerful tool for data exploration and communication.

In our example here,
we would come to widely different conclusions about the behaviour of the data
for the four different data sets.

Sets A and C are roughly linearly increasing at similar rates,
whereas set B reaches a plateau and starts to drop,
and set D has a constant X-value for all numbers except one big outlier.

### A modern take on Anscombe's quartet

For a more recent, dynamic, and avian illustration
of how graphical representations are much easier for us to interpret,
check out the [Datasaurus Dozen animation](https://www.autodesk.com/research/publications/same-stats-different-graphs) below.
It displays several different datasets,
all with the same mean, standard deviation and correlation between X and Y,
but looking at the data graphically shows us how different these datasets actually are.

<figure>
  <img src="https://blog.revolutionanalytics.com/downloads/DataSaurus%20Dozen.gif" alt="Datasaurus Dozen Animation" style="width:100%; max-width:600px;">
  <figcaption>The Datasaurus Dozen: Datasets with identical summary statistics but very different distributions.</figcaption>
</figure>

::: {.callout-warning}
## Beware of Visualization Pitfalls

While powerful, data visualization can lead to misinterpretation if not done carefully. Learn about common traps and best practices in [Data Visualization: A practical introduction](https://socviz.co/lookatdata.html#lookatdata) by Kieran Healy (Sections 1-1.2).

:::

## High level declarative vs low level imperative visualization tools

Declarative visualization tools allow you to give a high-level specification of *what* you want the visualization to include, rather than *how* to implement the visualization.

They focus on **data and relationships**, rather than **plot construction details.** 

Consider the difference between these instructions:

::: {.panel-tabset}

# Declarative instruction

**"Color my data by the column `country`"**

**Focus**: data, graphical marks, and encoding channels

# Imperative instruction

**"Go through this data frame and plot any observations of `country1` in blue, any observations of `country2` in red"**

**Focus**: for-loops, low-level drawing commands, *etc*
:::

With declarative tools, you simply have to declare links between data variables (e.g., country) and visual encoding channels (e.g., the x-axis, y-axis, color, *etc*). The rest of the plot details are handled automatically. 

As a result, you can create an impressive range of visualizations - from simple to sophisticated - using a concise grammar. It is also much easier to change between plot types, and accomodate changes in your underlying data. 

::: {.callout-note icon="false"}
## Exercise
 **Examine this visualization of the size of petals in Iris flowers. Try to spot the difference in the code between the declarative and imperative approaches.**

```{python}
#| echo: false
#| output: false
import matplotlib.pyplot as plt
import seaborn as sns
import altair as alt
df = sns.load_dataset('iris')
plt.ioff()

```

::: {.panel-tabset}

# Declarative

```{python}

alt.Chart(data.iris()).mark_circle().encode(
    x='petalLength',
    y='petalWidth',
    color='species'
)

```

# Imperative
```{python}

fig, ax = plt.subplots()
colors = ['#4E7DA6', '#F28A2E', '#F29191']

for color, species in zip(colors, df['species'].unique()):
    tmp = df[df['species'] == species]
    ax.scatter(tmp['petal_length'], tmp['petal_width'], label=species, color=color)
```

```{python}
#| echo: false
ax.legend()
ax.set_xlabel('Petal Length')
ax.set_ylabel('Petal Width')
plt.show()
```

:::

::: {.callout-tip icon="false" collapse="true"}
## Answer

The declarative code says what we want to visualize (e.g., `petalLength`, `petalWidth`) rather than how to construct the visualization (e.g., defining colors, using for loops).  
::: 
<br>

:::

## The R and Python visualization ecosystems

There are a wide variety of high-level and low-level tools for visualizing data in R and Python. 

In this book we will focus on [Altair](https://altair-viz.github.io/) (Python and R) and [ggplot](https://ggplot2.tidyverse.org/), two of the most prominent declarative statistical visualization libraries.

**If there are so many high level tools, why focus on Altair and ggplot?** 

Other high level libraries like seaborn and plotly use a top-down approach, focusing on the type of plot to build rather than building from the data. Such libraries often have dedicated functions for each visualization, e.g. `barplot()`, `scatterplot()`.

While there are some benefits to this approach, it requires you to memorize each individual function rather than reusable building blocks, and it makes it more difficult to combine visualizations. Instead, this course emphasizes a grammar-based, bottom-up approach due to its flexibility and power. 

```{mermaid}
%%{init: {'flowchart': {'width': 800}}}%%
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000

    %% R ecosystem
    base[base]:::lowLevel
    grid[grid]:::lowLevel
    lattice[lattice]:::highLevel
    ggplot[ggplot]:::highLevel
    ggiraph[ggiraph]:::highLevel
    ggplotly[ggplotly]:::highLevel
    plotly_r[plotly]:::lowLevel
    patchwork[patchwork/cowplot]:::alignmentTool
    htmlwidgets[htmlwidgets]:::javascript
    altair_r[Altair]:::highLevel

    %% JavaScript-related
    js[JavaScript]:::javascript
    d3[D3]:::javascript
    vega[Vega]:::javascript
    vegalite[Vega-Lite]:::javascript

    %% Python ecosystem
    matplotlib[Matplotlib]:::lowLevel
    plotnine[Plotnine]:::highLevel
    pandas[Pandas]:::highLevel
    seaborn[Seaborn]:::highLevel
    holoviz[HoloViz]:::highLevel
    bokeh[Bokeh]:::lowLevel
    plotly_py[Plotly]:::lowLevel
    plotly_express[Plotly Express]:::highLevel
    altair[Altair]:::highLevel

    %% Subgraph for R ecosystem
    subgraph R_Ecosystem[R Ecosystem]
        base --> grid
        grid --> lattice & ggplot
        lattice & ggplot --> patchwork
        ggplot -.-> ggiraph & ggplotly
        ggplotly --> plotly_r
        htmlwidgets --> ggiraph & plotly_r & altair_r
    end

    %% Subgraph for JavaScript ecosystem
    subgraph JS_Ecosystem[JavaScript Ecosystem]
        js --> d3
        d3 --> vega
        vega --> vegalite
    end

    %% Subgraph for Python ecosystem
    subgraph Python_Ecosystem[Python Ecosystem]
        matplotlib --> plotnine & pandas & seaborn & holoviz
        holoviz --> bokeh
        plotly_py --> plotly_express
        vegalite --> altair & altair_r
    end

    %% Connections between ecosystems
    js --> htmlwidgets & bokeh & plotly_py


```

```{mermaid}
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000
    %% Legend items
    AT[Alignment Tool]:::alignmentTool
    HL[High Level]:::highLevel
    LL[Low Level]:::lowLevel
    JS[JavaScript]:::javascript
```

## What is a graphical grammar?

A graphical grammar is a system for creating visualizations by combining basic elements according to specific rules. It parallels the grammars of natural and programming languages, but applies to visual components.

We are familiar with grammatical rules for natural languages,
where they tell us how to combine words into sentences
to convey particular meanings.

In programming, different languages have different grammar, for instance if you try to write ```"hello" + "world"``` in Python the grammar of Python defines that the addition of string should perform concatenation so the returned result is `"helloworld"`.

In contrast, the grammar of R says that there is no such thing as addition of strings,
so it throws an error complaining that non-numeric arguments were passed to the `+` operator.

**Graphical grammar**

Likewise for a visualization grammar,
different packages make different choices
for what happens when different visual elements are added together,
and which those visual elements are.

Key components of a graphical grammar include:

1. **Canvas**: The background or base of the chart.
2. **Geometric marks**: Visual elements representing data (e.g., bars, dots).
3. **Visual encoding**: Rules for mapping data to visual properties.

Unlike traditional charting tools that offer pre-made chart types, a grammar-based approach is more flexible. It allows the user to construct custom visualizations from fundamental building blocks.

The following table illustrates the similarities between the grammars of programming, natural language and graphics:

| Component | Natural Language | Programming Language | Graphical Grammar |
|-----------|-------------------|----------------------|-------------------|
| Basic Units | Words | Variables, literals | Marks (points, lines, bars) |
| Syntax Rules | Word order, punctuation | Syntax rules, operators | Rules for combining marks, layers, aesthetics |
| Semantics | Word meanings, context | Expression meanings | Meanings of visual encodings |
| Composition | Sentences, paragraphs | Statements, code blocks | Layers, facets |
| Output | Text | Executable code | Data visualizations |
| Modifiers | Adjectives, adverbs | Attributes, parameters | Scales, legends, annotations |

Understanding these parallels enables users to approach data visualization systematically, leveraging a defined set of components and rules.

## Coding with grammar in Altair and ggplot

Altair and ggplot offer a powerful and concise visualization grammar for quickly building a wide range of statistical graphics. 

In brief, you first create a canvas/chart, then you encode your data variables as different dimensions in this chart (x, y, color, etc) and add geometric marks to represent the data (points, lines, etc). You can see an illustration of this in the image below, together with how `ggplot` (top) and `altair` (bottom) uses the grammatical components in its syntax. The exact syntax is slightly different, but the overall structure very much the same:

![Alt text](/img/grammar-of-graphics.jpeg)

**Let's get coding**

Data in Altair and ggplot is built around ["tidy"](http://vita.had.co.nz/papers/tidy-data.html) dataframes,
which consists of a set of named data *columns*
with one feature each and rows with one observation each.
We will also regularly refer to data columns as data *fields*.
We will focus on Altair but you can toggle codeblocks to see how to create the same charts in ggplot.


We will often use datasets
from the [vega-datasets](https://github.com/vega/vega-datasets) repository, some which are directly available as Pandas data frames. The cars dataset provides a rich opportunity to explore historical trends in automotive design, performance, and efficiency.

::: {.panel-tabset}
## Altair
```{python}
#| output: false
import altair as alt
import pandas as pd


url = 'https://raw.githubusercontent.com/joelostblom/teaching-datasets/main/cars.csv'
# `parse_dates` makes sure a column is stored as a date object in pandas
cars = pd.read_csv(url, parse_dates=['Year'])
cars
```

```{python}
#| echo: false
show_df(cars)
```

Datasets in the vega-datasets collection can also be accessed via URLs. For more information about data frames - and some useful transformations to prepare Pandas data frames for plotting with Altair! - see the [Specifying Data with Altair documentation](https://altair-viz.github.io/user_guide/data.html).

## ggplot

```{r}
#| echo: false
#| output: false
suppressPackageStartupMessages(library(tidyverse))
```

```{r}
#| output: false
library(tidyverse)

url = 'https://raw.githubusercontent.com/joelostblom/teaching-datasets/main/cars.csv'
cars = read_csv(url, show_col_types = FALSE)
cars
```

```{python}
#| echo: false
show_df(ro.r['cars'])
```

:::

::: {.column-margin}

<strong> Stellar Charts </strong>
<br>
Altair is the name of a star in the same constellation as the star Vega, which is also the name of the Javascript library that Altair is built upon. Meanwhile, the "gg" in ggplot is a reference to the book "Grammar of Graphics",
which inspired the creation of the ggplot library. 

<br>
![](https://upload.wikimedia.org/wikipedia/commons/6/69/Altair.jpg)

:::

The fundamental object in Altair is the `Chart`, which takes a data frame as a single argument `alt.Chart(cars)`.

With a chart object in hand, we can now specify how we would like the data to be visualized. We first indicate what kind of geometric *mark* we want to use to represent the data. We can set the `mark` attribute of the chart object using the the `Chart.mark_*` methods.

For example, we can show the data as a point using `mark_point()`:


```{python}
alt.Chart(cars).mark_point()
```


Here the rendering consists of one point per row in the dataset, all plotted on top of each other, since we have not yet specified positions for these points.

To visually separate the points, we can map various *encoding channels*, or *channels* for short, to fields in the dataset. For example, we could *encode* the field `Miles_per_Gallon` of the data using the `x` channel, which represents the x-axis position of the points. To specify this, use the `encode` method:


::: {.panel-tabset}

## Altair
```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon'
)
```

## ggplot


```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y=0)) +
  geom_point()
```

::: {.column-margin}

<br>
<br>

In ggplot2, you begin by creating a plot object with your dataset, such as `ggplot(cars)`. This is similar to Altair's `Chart(cars)`. To visualize the data, you add a geometric object like `geom_point()`, which is conceptually equivalent to Altair's `mark_point()`. Initially, this would plot all points at the origin. To meaningfully represent the data, you map variables to visual properties using `aes()`. For instance, to plot Miles per Gallon on the x-axis, you'd use `aes(x = Miles_per_Gallon)` within `geom_point()`. This corresponds to Altair's `encode` method. 
:::

:::
The `encode()` method builds a key-value mapping between encoding channels (such as `x`, `y`, `color`, `shape`, `size`, *etc.*) to fields in the dataset, accessed by field name. For Pandas data frames, Altair automatically determines an appropriate data type for the mapped column, which in this case is the *nominal* type, indicating unordered, categorical values.




You can also see that there is a button with three dots
to the top right.
If you click this you will have options to save the chart
and to open the underlying Vega-Lite code.

Though we've now separated the data by one attribute, we still have multiple points overlapping within each category. Let's further separate these by adding a `y` encoding channel;
for example lets say we wanted to answer the question:
"How is a cars fuel efficiency related to its horsepower?"

::: {.panel-tabset}

## Altair

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower'
)
```

## ggplot

```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y = Horsepower)) +
    geom_point()
```

::: {.column-margin}

<br>
<br>
The default ggplot style is quite different from that of Altair.
Both have advantages,
and they are easy to customize to look however you want,
which we will also get into later.
Note that ggplot does not including the origin of the plot (x=0, y=0) by default,
but Altair does for many cases.

:::
::: 

Here we can see that there seems to be a negative correlation with Horsepower and Miles_per_Gallon:
More powerful cars consume more gas.

But there might be other variables that also influence this relationship,
e.g. the weight of the car probably matters for fuel efficiency,
since more force is needed to propel a bigger mass.
We can add more dimensions to this chart,
e.g. specifying which column we want to color the points by
and Altair will automatically figure out an appropriate colorscale to use.


::: {.panel-tabset}

# Altair
```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Weight_in_lbs'
)
```

# ggplot

```{r}
ggplot(cars, aes(x = Miles_per_Gallon, y = Horsepower, color = Weight_in_lbs)) +
    geom_point()
    
```

::: {.column-margin}
<br>
<br>
As with Altair,
ggplot chooses an appropriate continuous color scale for the quantitative data,
although it start from dark instead of light,
which could be related to the different choice of background color.
Notice also the difference in how the legend is added,
in Altair the overall width of the figure was increased,
whereas here the legend takes part of the figure width from the canvas,
which is made narrower.
:::

:::

Aha! Here we can see that weight is also correlated with Horsepower (positively)
and Miles_per_Gallon (negatively).
We can't say anything about causation from the plot alone,
just correlation.

One of the really neat things with Altair is that it extends its grammar 
to interactive plot elements as well.
We will see much more of this later in the book.
Let's add a tooltip to each data point with the name of the car,
hover over the data points to see the tooltip show up!


```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    tooltip='Name'
)
```


## Mission

Your name is **Zephyr Eco-Luna** and you have been tasked with investigating emissions in the city of Viridia. With a commitment to sustainability and a vision for a greener future, Viridia is taking proactive steps to investigate and mitigate its environmental impact. One significant area of focus is the emissions associated with food consumption and production.


```{=html}
<br>

        <div class="ministry-id-card">
            <div class="accent-line"></div>
            <div class="left-column">
                <div class="logo">Ministry of Environment</div>
                <div class="name">Zephyr Eco-Luna</div>
                <div class="info">
                    <div class="info-item">
                        <span class="label">Position</span>
                        <span class="value">Emissions Investigator</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Department</span>
                        <span class="value">Urban Food Systems</span>
                    </div>
                    <div class="info-item">
                        <span class="label">ID Number</span>
                        <span class="value">EI-2024-0042</span>
                    </div>
                    <div class="info-item">
                        <span class="label">Clearance</span>
                        <span class="value">Level 3</span>
                    </div>
                </div>
                <div class="footer">Protecting Our Future • Est. 2024</div>
            </div>
            <div class="right-column">
                <img src="/img/zephyr.jpg" alt="Avatar" class="avatar">
            </div>
        </div>
<br>
```

To start with your investigation, you’ll need to visualize the emissions data effectively. This will help unlock insights crucial for the Ministry of Environment.


```{python}
import pandas as pd
df_food = pd.read_csv("data/aggregated__food_data.csv")

df_food
```

<img src="/img/environ_minister.jpg" alt="Avatar" class="avatar" style="display: none;">

### Exercise 1: Planning your analysis

Before you start, your boss **Minister Reed** has a few questions for you...

```{ojs}
//| echo: false
{
    
const apiUrl = "https://openaiproxy-621feba224c9.herokuapp.com/api/proxy";

const instructions = "You are Minister Reed of the city of Viridia, a sharp-witted, impatient but supportive environmental minister. Your colleague Zephyr has been tasked with creating an Emissions Report. Guide Zephyr toward understanding why a complete picture is necessary and why including the Total Food Supply (kg/capita/yr) column matters (alongside the Emissions Kg CO2 / kg product). Once you get a satisfactory answer, end the conversation immediately. You are in a phone text convo.";

const first_message = "Zephyr, I need your Emissions Report on my desk by 2pm. Remind me why you are including the Total Food Supply in your analysis?";

let messageCount = 0;

// Initialize messages array with system instructions and initial message
let messages = [
  { role: "system", content: instructions },
  { role: "assistant", content: first_message }
];

async function sendOpenAIRequest(prompt) {
  try {
    // Add user message to conversation history
    messages.push({ role: "user", content: prompt });

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: "gpt-4o",
        messages: messages,
        temperature: 1,
        max_tokens: 100,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    const assistantResponse = data.choices[0].message.content;

    // Add assistant's response to conversation history
    messages.push({ role: "assistant", content: assistantResponse });

    return assistantResponse;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

const container = html`<div id="chat-container">
  <div class="highlight-line"></div>
  <div id="chat-display"></div>
  <textarea id="user-input" placeholder="Enter your message here"></textarea>
  <button id="submit-button">Send Message</button>
</div>`;

const chatDisplay = container.querySelector('#chat-display');
const userInput = container.querySelector('#user-input');
const submitButton = container.querySelector('#submit-button');

function createChatMessageHTML(content, isBoss) {
  return html`
    <div class="chat-message ${isBoss ? 'boss-message' : ''}">
      <div class="chat-avatar" style="background-image: url('${isBoss ? '/img/environ_minister.jpg' : '/img/zephyr.jpg'}')"></div>
      <div class="chat-message-content">
        <div class="chat-sender-name">${isBoss ? 'Minister Reed' : 'Zephyr Eco-Luna'}</div>
        <div>${content}</div>
      </div>
    </div>
  `;
}

// Initial message
chatDisplay.appendChild(createChatMessageHTML(first_message, true));

submitButton.onclick = async () => {
  const prompt = userInput.value;
  if (prompt.trim() === '') return;

  messageCount++;

  // Display user's message
  chatDisplay.appendChild(createChatMessageHTML(prompt, false));
  userInput.value = '';
  chatDisplay.scrollTop = chatDisplay.scrollHeight;

  try {
    const response = await sendOpenAIRequest(prompt);
    chatDisplay.appendChild(createChatMessageHTML(response, true));
  } catch (error) {
    chatDisplay.appendChild(createChatMessageHTML("Error: " + error.message, true));
  }

  // Scroll to the bottom of the chat display
  chatDisplay.scrollTop = chatDisplay.scrollHeight;
};

chatDisplay.scrollTop = chatDisplay.scrollHeight;

return html`${container}`;
}
```


### Exercise 2: Visualizing the data

It's time to put the Grammar of Graphics to good use. Create a scatterplot chart of the food supply and emissions data by following these steps:

1. Instantiate the chart from the `df_food` dataframe
2. Choose an appropriate graphical `mark_*()`
3. Map `Total Food Supply (kg/capita/yr)` and `Emissions (Kg CO2 / kg product)` to visual encoding channels


::: {.callout-tip icon="false" collapse="true"}

# Solution
```{python}

alt.Chart(df_food).mark_point().encode(
    x='Total Food Supply (kg/capita/yr)',
    y='Emissions (Kg CO2 / kg product)',
    tooltip='Food Item'
)
```

:::

### Exercise 3: Inspecting individual marks

These are striking results! There are some clear clusters and outliers in the data. Add a tooltip to your chart to investigate which foods these are.

### Exercise 4: Reporting your results

```{ojs}
//| echo: false
{
  const apiUrl = "https://openaiproxy-621feba224c9.herokuapp.com/api/proxy";
  const instructions = "You are Minister Reed of the city of Viridia, a sharp witted, impatient but supportive environmental minister. You are talking with your colleague Zephyr who has been tasked with creating an Emissions Report. Don't give solution in first message, but you must provide it after 3 messages and end the conversation definitively when you do. The report found shocking findings: beef Emissions Kg CO2 / kg product are incredibly high (around 60) compared to other food and supply is also high for it. Another is milk, which has Total Food Supply of around 190 (kg/capita/yr) and moderate emissions. The exciting part is that many vegetables etc have extremely low emissions. You see HUGE potential in reducing beef consumption in Viridia given the climate disaster)";
  const first_message = "Zephyr, I've been waiting! What patterns did you see in the food emissions data?";
  let messageCount = 0;

  let messages = [
    { role: "system", content: instructions },
    { role: "assistant", content: first_message }
  ];

  async function sendOpenAIRequest(prompt) {
    try {
      messages.push({ role: "user", content: prompt });

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: messages,
          temperature: 1,
          max_tokens: 100,
          top_p: 1,
          frequency_penalty: 0,
          presence_penalty: 0
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      const assistantResponse = data.choices[0].message.content;
      messages.push({ role: "assistant", content: assistantResponse });

      return assistantResponse;
    } catch (error) {
      console.error("Error:", error);
      throw error;
    }
  }

  const container = html`<div id="chat-container">
    <div class="highlight-line"></div>
    <div id="chat-display"></div>
    <textarea id="user-input" placeholder="Enter your message here"></textarea>
    <button id="submit-button">Send Message</button>
  </div>`;

  const chatDisplay = container.querySelector('#chat-display');
  const userInput = container.querySelector('#user-input');
  const submitButton = container.querySelector('#submit-button');

  function createChatMessageHTML(content, isBoss) {
    return html`
      <div class="chat-message ${isBoss ? 'boss-message' : ''}">
        <div class="chat-avatar" style="background-image: url('${isBoss ? '/img/environ_minister.jpg' : '/img/zephyr.jpg'}')"></div>
        <div class="chat-message-content">
          <div class="chat-sender-name">${isBoss ? 'Minister Reed' : 'Zephyr Eco-Luna'}</div>
          <div>${content}</div>
        </div>
      </div>
    `;
  }

  // Initial message
  chatDisplay.appendChild(createChatMessageHTML(first_message, true));

  submitButton.onclick = async () => {
    const prompt = userInput.value;
    if (prompt.trim() === '') return;
    messageCount++;
    chatDisplay.appendChild(createChatMessageHTML(prompt, false));
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
    userInput.value = '';
    try {
      const response = await sendOpenAIRequest(prompt);
      chatDisplay.appendChild(createChatMessageHTML(response, true));
    } catch (error) {
      chatDisplay.appendChild(createChatMessageHTML("Error: " + error.message, true));
    }
    // Scroll to the bottom of the chat display
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  };

  chatDisplay.scrollTop = chatDisplay.scrollHeight;

  return html`${container}`;
}
```

```{=html}
<div class="song-container">
  <div class="song-details">
    <div class="song-icon">🎵</div>
    <div class="song-info">
      <div class="song-title">Data Viz Ecosystem</div>
      <div class="song-artist">Generated with artificial intelligence</div>
    </div>
  </div>
  <div class="audio-player">
    <audio controls>
    <source src="/audio/data-viz-ecosystem.mp3" type="audio/mpeg"></source>
    Your browser does not support the audio element.
    </audio>
  </div>
</div>
```