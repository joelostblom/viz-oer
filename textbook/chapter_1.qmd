---
title: "Intro to data visualization and graphical grammars"
jupyter: "531"
---

::: {.callout-note title="Learning outcomes"}
- **Explain**: The main advantages of visualizing data instead of presenting it with numbers is that they are easier to interpret for humans.

- **Describe**: A grammar of graphics defines the grammatical rules that can be used to construct entire visualizations from smaller building blocks.

- **Apply**: Be able to use the visualization grammars Altair and ggplot and create a basic chart via `alt.Chart()...` / `ggplot()...`

- **Explain**: The advantage of high level level syntax allows us to think in terms of the data, rather than graphical details.
:::

### What is data visualization?

At its core,
data visualization is about representing numbers with graphical elements
such as the position of a line, the length of a bar, or the colour of a point.
We often use visualizations to explore data ourselves,
and to effectively communicate our insights to others,
as we will learn in later modules of this book.

### What is the purpose of visualizing data?

We often visualize data in order to help us answer a specific question
we have about our dataset,
but it can also help us generate new questions.

Before creating a visualization,
it is important that you
think about why you are making it,
and what you want to achieve from creating this plot.
Is there a specific question you are trying to answer,
like comparing the relationship between two dataframe columns?
Or are you creating a plot
to help you understand the structure of your data more in general,
such as plotting the distribution of each dataframe column?

In either case,
it can be extremely helpful to draw out your plot with pen and paper first.
This helps you think about if the plot you are creating makes sense
or if there is another plot better suited for the task at hand.
Drawing with pen and paper also makes it easier to write the code afterwards,
since you clearly know what you are expecting
the visualization to look like.

### Why bother visualizing data instead of showing raw numbers?

To understand why visualizations are so powerful,
it is helpful to remember that to answer a question,
we often have to put the data in a format that is easy for us humans to interpret.
Because our number systems have only been around for about 5,000 years,
we need to assert effort and train ourselves
to recognize structure in numerical data.

Visual systems,
on the other hand,
have undergone refinement during 500,000,000 years of evolution,
so we can instinctively recognize visual patterns
and accurately estimate visual properties
such as colours and distances.

Practically,
this means that we can arrive at correct conclusions faster
from studying visual rather than numerical
representations of the same data.
For example, have a look at the
four sets of numbers in the table on the slide.
Can you see the differences in the general trends between these four sets of numbers?
This is a slightly modified version of the original,
<a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet" target="_blank">which was put together by statistician Francis Anscombe in the
70s.</a>


```{python}
#| echo: false

import altair as alt
import pandas as pd
from vega_datasets import data
from IPython.display import display_html, HTML

anscombe = data.anscombe()
anscombe['Set'] = anscombe['Series'].map({'I': 'A', 'II': 'B', 'III': 'C', 'IV': 'D'})
anscombe = anscombe.drop(columns='Series')
anscombe.loc[anscombe['Y'] == anscombe['Y'].max(), 'Y'] = 8.5

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s = s + (
        df
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

display(HTML(html_content))
```

#### Summary statistics don't tell the whole story

You are likely not able to see much difference between the data sets
in the table above.
What about if I showed you a few commonly used numerical summaries of the data?

```{python}
#| echo: false

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s += (
        df
        .agg(['mean', 'std'])
        .round(2)
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
        .replace('>7.11',  ' style="background-color:#4853a4; color:#ffffff"> <b>7.11</b>')
        .replace('>1.15',  ' style="background-color:#4853a4; color:#ffffff"> <b>1.15</b>')
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

display(HTML(html_content))
```

<br>
Summaries,
such as the mean and standard deviation,
are helpful statistical tools
that are often useful for detecting the differences between datasets.
However,
since they collapse the data into just a few numbers,
statistical summaries can't tell the whole story about the data
and there can be important differences between datasets
that summaries fail to reveal.

Below,
the mean and standard deviation indicate that set C
is slightly different from the other sets of data
in terms of the centre of the sample distribution and the spread of that distribution,
while the remaining three sets of data have a similar centre and spread.

#### Plotting the data immediately reveals patterns in the data 

So if you can't really see any patterns in the data
and the statistical summaries are the same,
that must mean that the four sets are pretty similar, right?
Sounds about right to me so let's go ahead and plot them to have a quick look and...

```{python}
#| echo: false

def bigger_font():
    return {
        'config': {
            'view': {'continuousWidth': 400, 'continuousHeight': 300},
            'legend': {'symbolSize': 14, 'titleFontSize': 14, 'labelFontSize': 14},
            'axis': {'titleFontSize': 14, 'labelFontSize': 12},
            'header': {'titleFontSize': 16, 'labelFontSize': 14},
            'encoding': {'x': {'scale': {'zero': False}}}}}
alt.themes.register('bigger_font', bigger_font)
alt.themes.enable('bigger_font')
(alt.Chart(anscombe).mark_circle(size=80, opacity=1).encode(
    x='X',
    y='Y')
 .properties(width=300, height=200)
 .facet('Set', columns=2)
 .configure_axis(grid=True)
 .configure_header(title=None)
)
```

... what the... how... there must be something wrong, right?
Well what is wrong is that humans are not good at detecting patterns in raw numbers,
and we don't have good intuition about which combination of numbers can contribute to the same statistical summaries.
But guess what we excel at? Detecting visual patterns!

It is immediately clear to us how these sets of numbers differ
once they are shown as graphical objects 
instead of textual objects.
We could not detect these patterns from only looking at the raw numbers or summary statistics
This is one of the main reasons why data visualization
is such a powerful tool for data exploration and communication.

In our example here,
we would come to widely different conclusions about the behaviour of the data
for the four different data sets.

Sets A and C are roughly linearly increasing at similar rates,
whereas set B reaches a plateau and starts to drop,
and set D has a constant X-value for all numbers except one big outlier.

#### A modern take on Anscombe's quartet

For a more recent, dynamic, and avian illustration
of how graphical representations are much easier for us to interpret,
check out the [Datasaurus Dozen animation](https://www.autodesk.com/research/publications/same-stats-different-graphs) below.
It displays several different datasets,
all with the same mean, standard deviation and correlation between X and Y,
but looking at the data graphically shows us how different these datasets actually are.

![](https://blog.revolutionanalytics.com/downloads/DataSaurus%20Dozen.gif)

::: {.callout-warning}
### Beware of Visualization Pitfalls

While powerful, data visualization can lead to misinterpretation if not done carefully. Learn about common traps and best practices in [Data Visualization: A practical introduction](https://socviz.co/lookatdata.html#lookatdata) by Kieran Healy (Sections 1-1.2).

:::

## Creating plots in R and Python

There is a plethora of visualization tools in each language,
here is a brief overview.

### The R and Python visualization landscapes

```{mermaid}
%%{init: {'flowchart': {'width': 800}}}%%
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000
    classDef highlight fill:#87CEFA,stroke:#00FF00,color:#000,stroke-width:2px

    %% R ecosystem
    base[base]:::lowLevel
    grid[grid]:::lowLevel
    lattice[lattice]:::highLevel
    ggplot[ggplot]:::highlight
    ggiraph[ggiraph]:::highLevel
    ggplotly[ggplotly]:::highLevel
    plotly_r[plotly]:::lowLevel
    patchwork[patchwork/cowplot]:::alignmentTool
    htmlwidgets[htmlwidgets]:::javascript

    %% JavaScript-related
    js[JavaScript]:::javascript
    d3[D3]:::javascript
    vega[Vega]:::javascript
    vegalite[Vega-Lite]:::javascript

    %% Python ecosystem
    matplotlib[Matplotlib]:::lowLevel
    plotnine[Plotnine]:::highLevel
    pandas[Pandas]:::highLevel
    seaborn[Seaborn]:::highLevel
    holoviz[HoloViz]:::highLevel
    bokeh[Bokeh]:::lowLevel
    plotly_py[Plotly]:::lowLevel
    plotly_express[Plotly Express]:::highLevel
    altair[Altair]:::highlight

    %% Subgraph for R ecosystem
    subgraph R_Ecosystem[R Ecosystem]
        base --> grid
        grid --> lattice & ggplot
        lattice & ggplot --> patchwork
        ggplot -.-> ggiraph & ggplotly
        ggplotly --> plotly_r
        htmlwidgets --> ggiraph & plotly_r
    end

    %% Subgraph for JavaScript ecosystem
    subgraph JS_Ecosystem[JavaScript Ecosystem]
        js --> d3
        d3 --> vega
        vega --> vegalite
    end

    %% Subgraph for Python ecosystem
    subgraph Python_Ecosystem[Python Ecosystem]
        matplotlib --> plotnine & pandas & seaborn & holoviz
        holoviz --> bokeh
        plotly_py --> plotly_express
        vegalite --> altair
    end

    %% Connections between ecosystems
    js --> htmlwidgets & bokeh & plotly_py
```

```{mermaid}
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000

    %% Legend items
    AT[Alignment Tool]:::alignmentTool
    HL[High Level]:::highLevel
    LL[Low Level]:::lowLevel
    JS[JavaScript]:::javascript
```

In this book we will focus on Altair and ggplot,
and as you can see in the image above,
these are both high level (or declarative) visualization libraries.

### High level declarative vs low level imperative visualization tools

Declarative visualization tools allow you to give a high-level specification of *what* you want the visualization to include, rather than *how* to implement the visualization.

They focus on **data and relationships**, rather than **plot construction details.** 

Consider the difference between these instructions:

::: {.panel-tabset}

# Declarative instruction

**"Color my data by the column `country`"**

**Focus**: data, graphical marks, and encoding channels

# Imperative instruction

**"Go through this data frame and plot any observations of `country1` in blue, any observations of `country2` in red"**

**Focus**: for-loops, low-level drawing commands, *etc*
:::

With declarative tools, you simply have to declare links between data variables (e.g., country) and visual encoding channels (e.g., the x-axis, y-axis, color, *etc*). The rest of the plot details are handled automatically. 

As a result, you can create an impressive range of visualizations - from simple to sophisticated - using a concise grammar. It is also much easier to change between plot types, and accomodate changes in your underlying data. 

::: {.callout-note icon="false"}
## Exercise
 **Examine this visualization of the size of petals in Iris flowers. Try to spot the difference in the code between the declarative and imperative approaches.**

```{python}
#| echo: false
#| output: false
import matplotlib.pyplot as plt
import seaborn as sns
import altair as alt
df = sns.load_dataset('iris')
plt.ioff()

```

::: {.panel-tabset}

# Declarative

```{python}

alt.Chart(data.iris()).mark_circle().encode(
    x='petalLength',
    y='petalWidth',
    color='species'
)

```

# Imperative
```{python}

fig, ax = plt.subplots()
colors = ['#4E7DA6', '#F28A2E', '#F29191']

for color, species in zip(colors, df['species'].unique()):
    tmp = df[df['species'] == species]
    ax.scatter(tmp['petal_length'], tmp['petal_width'], label=species, color=color)
```

```{python}
#| echo: false
ax.legend()
ax.set_xlabel('Petal Length')
ax.set_ylabel('Petal Width')
plt.show()
```

:::

::: {.callout-tip icon="false" collapse="true"}
## Answer

The declarative code says what we want to visualize (e.g., `petalLength`, `petalLength`) rather than how to construct the visualization (e.g., defining colors, using for loops).  
::: 
<br>

:::

### Using a graphical grammar

#### What is a graphical grammar?

A graphical grammar is a system for creating visualizations by combining basic elements according to specific rules. It parallels the grammars of natural and programming languages, but applies to visual components.

Key components of a graphical grammar include:

1. **Canvas**: The background or base of the chart.
2. **Geometric marks**: Visual elements representing data (e.g., bars, dots).
3. **Visual encoding**: Rules for mapping data to visual properties.

This approach differs from traditional charting tools that offer pre-made chart types. Instead, it provides flexibility to construct custom visualizations from fundamental building blocks.

The following table illustrates the structural similarities between graphical grammar and other language systems:

| Component | Natural Language | Programming Language | Graphical Grammar |
|-----------|-------------------|----------------------|-------------------|
| Basic Units | Words | Variables, literals | Marks (points, lines, bars) |
| Syntax Rules | Word order, punctuation | Syntax rules, operators | Rules for combining marks, layers, aesthetics |
| Semantics | Word meanings, context | Expression meanings | Meanings of visual encodings |
| Composition | Sentences, paragraphs | Statements, code blocks | Layers, facets |
| Output | Text | Executable code | Data visualizations |
| Modifiers | Adjectives, adverbs | Attributes, parameters | Scales, legends, annotations |

Understanding these parallels enables users to approach data visualization systematically, leveraging a defined set of components and rules.

