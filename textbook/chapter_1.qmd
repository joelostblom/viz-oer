---
title: "Intro to data visualization and graphical grammars"
jupyter: "531"
---

::: {.callout-note title="Learning outcomes"}
- **Explain**: The main advantages of visualizing data instead of presenting it with numbers is that they are easier to interpret for humans.

- **Explain**: The advantage of high level level syntax allows us to think in terms of the data, rather than graphical details.

- **Describe**: A grammar of graphics defines the grammatical rules that can be used to construct entire visualizations from smaller building blocks.

- **Apply**: Be able to use the visualization grammars Altair and ggplot and create a basic chart via `alt.Chart()...` / `ggplot()...`

:::

### What is data visualization?

At its core,
data visualization is about representing numbers with graphical elements
such as the position of a line, the length of a bar, or the colour of a point.
We often use visualizations to explore data ourselves,
and to effectively communicate our insights to others,
as we will learn in later modules of this book.

### What is the purpose of visualizing data?

We often visualize data in order to help us answer a specific question
we have about our dataset,
but it can also help us generate new questions.

Before creating a visualization,
it is important that you
think about why you are making it,
and what you want to achieve from creating this plot.
Is there a specific question you are trying to answer,
like comparing the relationship between two dataframe columns?
Or are you creating a plot
to help you understand the structure of your data more in general,
such as plotting the distribution of each dataframe column?

In either case,
it can be extremely helpful to draw out your plot with pen and paper first.
This helps you think about if the plot you are creating makes sense
or if there is another plot better suited for the task at hand.
Drawing with pen and paper also makes it easier to write the code afterwards,
since you clearly know what you are expecting
the visualization to look like.

### Why bother visualizing data instead of showing raw numbers?

To understand why visualizations are so powerful,
it is helpful to remember that to answer a question,
we often have to put the data in a format that is easy for us humans to interpret.
Because our number systems have only been around for about 5,000 years,
we need to assert effort and train ourselves
to recognize structure in numerical data.

Visual systems,
on the other hand,
have undergone refinement during 500,000,000 years of evolution,
so we can instinctively recognize visual patterns
and accurately estimate visual properties
such as colours and distances.

Practically,
this means that we can arrive at correct conclusions faster
from studying visual rather than numerical
representations of the same data.
For example, have a look at the
four sets of numbers in the table on the slide.
Can you see the differences in the general trends between these four sets of numbers?
This is a slightly modified version of the original,
<a href="https://en.wikipedia.org/wiki/Anscombe%27s_quartet" target="_blank">which was put together by statistician Francis Anscombe in the
70s.</a>


```{python}
#| echo: false

import altair as alt
import pandas as pd
from vega_datasets import data
from IPython.display import display_html, HTML

anscombe = data.anscombe()
anscombe['Set'] = anscombe['Series'].map({'I': 'A', 'II': 'B', 'III': 'C', 'IV': 'D'})
anscombe = anscombe.drop(columns='Series')
anscombe.loc[anscombe['Y'] == anscombe['Y'].max(), 'Y'] = 8.5

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s = s + (
        df
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

display(HTML(html_content))
```

#### Summary statistics don't tell the whole story

You are likely not able to see much difference between the data sets
in the table above.
What about if I showed you a few commonly used numerical summaries of the data?

```{python}
#| echo: false

s = ''
for set_name, df in anscombe.groupby('Set'):
    df = df.drop(columns='Set')
    df.columns = pd.MultiIndex.from_tuples([(set_name, 'X'), (set_name, 'Y')])
    s += (
        df
        .agg(['mean', 'std'])
        .round(2)
        .style
        .format('{:.2f}')
        .hide(axis='index')
        ._repr_html_()
        .replace('>7.11',  ' style="background-color:#4853a4; color:#ffffff"> <b>7.11</b>')
        .replace('>1.15',  ' style="background-color:#4853a4; color:#ffffff"> <b>1.15</b>')
    )

html_content = '<div class="dataframe-grid">' + s + '</div>'

display(HTML(html_content))
```

<br>
Summaries,
such as the mean and standard deviation,
are helpful statistical tools
that are often useful for detecting the differences between datasets.
However,
since they collapse the data into just a few numbers,
statistical summaries can't tell the whole story about the data
and there can be important differences between datasets
that summaries fail to reveal.

Below,
the mean and standard deviation indicate that set C
is slightly different from the other sets of data
in terms of the centre of the sample distribution and the spread of that distribution,
while the remaining three sets of data have a similar centre and spread.

#### Plotting the data immediately reveals patterns in the data 

So if you can't really see any patterns in the data
and the statistical summaries are the same,
that must mean that the four sets are pretty similar, right?
Sounds about right to me so let's go ahead and plot them to have a quick look and...

```{python}
#| echo: false

def bigger_font():
    return {
        'config': {
            'view': {'continuousWidth': 400, 'continuousHeight': 300},
            'legend': {'symbolSize': 14, 'titleFontSize': 14, 'labelFontSize': 14},
            'axis': {'titleFontSize': 14, 'labelFontSize': 12},
            'header': {'titleFontSize': 16, 'labelFontSize': 14},
            'encoding': {'x': {'scale': {'zero': False}}}}}
alt.themes.register('bigger_font', bigger_font)
alt.themes.enable('bigger_font')
(alt.Chart(anscombe).mark_circle(size=80, opacity=1).encode(
    x='X',
    y='Y')
 .properties(width=300, height=200)
 .facet('Set', columns=2)
 .configure_axis(grid=True)
 .configure_header(title=None)
)
```

... what the... how... there must be something wrong, right?
Well what is wrong is that humans are not good at detecting patterns in raw numbers,
and we don't have good intuition about which combination of numbers can contribute to the same statistical summaries.
But guess what we excel at? Detecting visual patterns!

It is immediately clear to us how these sets of numbers differ
once they are shown as graphical objects 
instead of textual objects.
We could not detect these patterns from only looking at the raw numbers or summary statistics
This is one of the main reasons why data visualization
is such a powerful tool for data exploration and communication.

In our example here,
we would come to widely different conclusions about the behaviour of the data
for the four different data sets.

Sets A and C are roughly linearly increasing at similar rates,
whereas set B reaches a plateau and starts to drop,
and set D has a constant X-value for all numbers except one big outlier.

#### A modern take on Anscombe's quartet

For a more recent, dynamic, and avian illustration
of how graphical representations are much easier for us to interpret,
check out the [Datasaurus Dozen animation](https://www.autodesk.com/research/publications/same-stats-different-graphs) below.
It displays several different datasets,
all with the same mean, standard deviation and correlation between X and Y,
but looking at the data graphically shows us how different these datasets actually are.

<figure>
  <img src="https://blog.revolutionanalytics.com/downloads/DataSaurus%20Dozen.gif" alt="Datasaurus Dozen Animation" style="width:100%; max-width:600px;">
  <figcaption>The Datasaurus Dozen: Datasets with identical summary statistics but very different distributions.</figcaption>
</figure>

::: {.callout-warning}
### Beware of Visualization Pitfalls

While powerful, data visualization can lead to misinterpretation if not done carefully. Learn about common traps and best practices in [Data Visualization: A practical introduction](https://socviz.co/lookatdata.html#lookatdata) by Kieran Healy (Sections 1-1.2).

:::

## Creating plots in R and Python

### High level declarative vs low level imperative visualization tools

Declarative visualization tools allow you to give a high-level specification of *what* you want the visualization to include, rather than *how* to implement the visualization.

They focus on **data and relationships**, rather than **plot construction details.** 

Consider the difference between these instructions:

::: {.panel-tabset}

# Declarative instruction

**"Color my data by the column `country`"**

**Focus**: data, graphical marks, and encoding channels

# Imperative instruction

**"Go through this data frame and plot any observations of `country1` in blue, any observations of `country2` in red"**

**Focus**: for-loops, low-level drawing commands, *etc*
:::

With declarative tools, you simply have to declare links between data variables (e.g., country) and visual encoding channels (e.g., the x-axis, y-axis, color, *etc*). The rest of the plot details are handled automatically. 

As a result, you can create an impressive range of visualizations - from simple to sophisticated - using a concise grammar. It is also much easier to change between plot types, and accomodate changes in your underlying data. 

::: {.callout-note icon="false"}
## Exercise
 **Examine this visualization of the size of petals in Iris flowers. Try to spot the difference in the code between the declarative and imperative approaches.**

```{python}
#| echo: false
#| output: false
import matplotlib.pyplot as plt
import seaborn as sns
import altair as alt
df = sns.load_dataset('iris')
plt.ioff()

```

::: {.panel-tabset}

# Declarative

```{python}

alt.Chart(data.iris()).mark_circle().encode(
    x='petalLength',
    y='petalWidth',
    color='species'
)

```

# Imperative
```{python}

fig, ax = plt.subplots()
colors = ['#4E7DA6', '#F28A2E', '#F29191']

for color, species in zip(colors, df['species'].unique()):
    tmp = df[df['species'] == species]
    ax.scatter(tmp['petal_length'], tmp['petal_width'], label=species, color=color)
```

```{python}
#| echo: false
ax.legend()
ax.set_xlabel('Petal Length')
ax.set_ylabel('Petal Width')
plt.show()
```

:::

::: {.callout-tip icon="false" collapse="true"}
## Answer

The declarative code says what we want to visualize (e.g., `petalLength`, `petalWidth`) rather than how to construct the visualization (e.g., defining colors, using for loops).  
::: 
<br>

:::

### The R and Python visualization ecosystems

There are a wide variety of high-level and low-level tools for visualizing data in R and Python. 

In this book we will focus on [Altair](https://altair-viz.github.io/) (Python and R) and [ggplot](https://ggplot2.tidyverse.org/), two of the most prominent declarative statistical visualization libraries.

**If there are so many high level tools, why focus on Altair and ggplot?** 

Other high level libraries like seaborn and plotly use a top-down approach, focusing on the type of plot to build rather than building from the data. Such libraries often have dedicated functions for each visualization, e.g. `barplot()`, `scatterplot()`.

While there are some benefits to this approach, it requires you to memorize each individual function rather than reusable building blocks, and it makes it more difficult to combine visualizations. Instead, this course emphasizes a grammar-based, bottom-up approach due to its flexibility and power. 

```{mermaid}
%%{init: {'flowchart': {'width': 800}}}%%
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000

    %% R ecosystem
    base[base]:::lowLevel
    grid[grid]:::lowLevel
    lattice[lattice]:::highLevel
    ggplot[ggplot]:::highLevel
    ggiraph[ggiraph]:::highLevel
    ggplotly[ggplotly]:::highLevel
    plotly_r[plotly]:::lowLevel
    patchwork[patchwork/cowplot]:::alignmentTool
    htmlwidgets[htmlwidgets]:::javascript
    altair_r[Altair]:::highLevel

    %% JavaScript-related
    js[JavaScript]:::javascript
    d3[D3]:::javascript
    vega[Vega]:::javascript
    vegalite[Vega-Lite]:::javascript

    %% Python ecosystem
    matplotlib[Matplotlib]:::lowLevel
    plotnine[Plotnine]:::highLevel
    pandas[Pandas]:::highLevel
    seaborn[Seaborn]:::highLevel
    holoviz[HoloViz]:::highLevel
    bokeh[Bokeh]:::lowLevel
    plotly_py[Plotly]:::lowLevel
    plotly_express[Plotly Express]:::highLevel
    altair[Altair]:::highLevel

    %% Subgraph for R ecosystem
    subgraph R_Ecosystem[R Ecosystem]
        base --> grid
        grid --> lattice & ggplot
        lattice & ggplot --> patchwork
        ggplot -.-> ggiraph & ggplotly
        ggplotly --> plotly_r
        htmlwidgets --> ggiraph & plotly_r & altair_r
    end

    %% Subgraph for JavaScript ecosystem
    subgraph JS_Ecosystem[JavaScript Ecosystem]
        js --> d3
        d3 --> vega
        vega --> vegalite
    end

    %% Subgraph for Python ecosystem
    subgraph Python_Ecosystem[Python Ecosystem]
        matplotlib --> plotnine & pandas & seaborn & holoviz
        holoviz --> bokeh
        plotly_py --> plotly_express
        vegalite --> altair & altair_r
    end

    %% Connections between ecosystems
    js --> htmlwidgets & bokeh & plotly_py


```

```{mermaid}
graph TD
    %% Color definitions
    classDef alignmentTool fill:#FF69B4,color:#000
    classDef highLevel fill:#87CEFA,color:#000
    classDef lowLevel fill:#FFA500,color:#000
    classDef javascript fill:#FFFFFF,color:#000
    %% Legend items
    AT[Alignment Tool]:::alignmentTool
    HL[High Level]:::highLevel
    LL[Low Level]:::lowLevel
    JS[JavaScript]:::javascript
```

<div class="song-container">
<div class="song-details">
<div class="song-icon">🎵</div>
<div class="song-info">
<div class="song-title">Data Viz Ecosystem</div>
<div class="song-artist">Generated with artificial intelligence</div>
</div>
</div>
<div class="audio-player">
<audio controls>
<source src="data-viz-ecosystem.mp3" type="audio/mpeg">
Your browser does not support the audio element.
</audio>
</div>
</div>

### What is a graphical grammar?

A graphical grammar is a system for creating visualizations by combining basic elements according to specific rules. It parallels the grammars of natural and programming languages, but applies to visual components.

We are familiar with grammatical rules for natural languages,
where they tell us how to combine words into sentences
to convey particular meanings.

In programming, different languages have different grammar, for instance if you try to write ```"hello" + "world"``` in Python the grammar of Python defines that the addition of string should perform concatenation so the returned result is `"helloworld"`.

In contrast, the grammar of R says that there is no such thing as addition of strings,
so it throws an error complaining that non-numeric arguments were passed to the `+` operator.

**Graphical grammar**

Likewise for a visualization grammar,
different packages make different choices
for what happens when different visual elements are added together,
and which those visual elements are.

Key components of a graphical grammar include:

1. **Canvas**: The background or base of the chart.
2. **Geometric marks**: Visual elements representing data (e.g., bars, dots).
3. **Visual encoding**: Rules for mapping data to visual properties.

Unlike traditional charting tools that offer pre-made chart types, a grammar-based approach is more flexible. It allows the user to construct custom visualizations from fundamental building blocks.

The following table illustrates the similarities between the grammars of programming, natural language and graphics:

| Component | Natural Language | Programming Language | Graphical Grammar |
|-----------|-------------------|----------------------|-------------------|
| Basic Units | Words | Variables, literals | Marks (points, lines, bars) |
| Syntax Rules | Word order, punctuation | Syntax rules, operators | Rules for combining marks, layers, aesthetics |
| Semantics | Word meanings, context | Expression meanings | Meanings of visual encodings |
| Composition | Sentences, paragraphs | Statements, code blocks | Layers, facets |
| Output | Text | Executable code | Data visualizations |
| Modifiers | Adjectives, adverbs | Attributes, parameters | Scales, legends, annotations |

Understanding these parallels enables users to approach data visualization systematically, leveraging a defined set of components and rules.

### Grammar in Altair and ggplot

Altair and ggplot offer a powerful and concise visualization grammar for quickly building a wide range of statistical graphics. 

In brief, you first create a canvas/chart, then you encode your data variables as different dimensions in this chart (x, y, color, etc) and add geometric marks to represent the data (points, lines, etc). You can see an illustration of this in the image below, together with how `ggplot` (top) and `altair` (bottom) uses the grammatical components in its syntax. The exact syntax is slightly different, but the overall structure very much the same:

![Alt text](grammar-of-graphics.jpeg)

### Building charts in Altair and ggplot

```{=html}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ministry of Environment Refined Wider ID Card</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .id-card {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            width: 640px;
            height: 300px;
            padding: 30px;
            display: flex;
            color: #333;
            position: relative;
            overflow: hidden;
        }
        .id-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(240,240,240,0.1) 0%,
                rgba(240,240,240,0.05) 25%,
                transparent 50%
            );
            transform: rotate(-10deg);
            pointer-events: none;
        }
        .left-column {
            flex: 3;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .right-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
        }
        .logo {
            font-size: 13px;
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #555;
            margin-bottom: 20px;
        }
        .avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #e0e0e0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .info {
            display: flex;
            flex-wrap: wrap;
        }
        .info-item {
            flex: 1 0 50%;
            margin: 5px 0;
            font-size: 13px;
        }
        .name {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        .label {
            font-weight: 500;
            color: #888;
            display: block;
        }
        .value {
            font-weight: 400;
            color: #333;
        }
        .footer {
            font-size: 11px;
            color: #888;
            align-self: flex-start;
            margin-top: 15px;
            letter-spacing: 1px;
        }
        .accent-line {
            position: absolute;
            top: 0;
            left: 25px;
            width: 3px;
            height: 50px;
            background-color: #3a7bd5;
        }
    </style>
</head>
<body>
    <div class="id-card">
        <div class="accent-line"></div>
        <div class="left-column">
            <div class="logo">Ministry of Environment</div>
            <div class="name">Zephyr Eco-Luna</div>
            <div class="info">
                <div class="info-item">
                    <span class="label">Position</span>
                    <span class="value">Emissions Investigator</span>
                </div>
                <div class="info-item">
                    <span class="label">Department</span>
                    <span class="value">Urban Food Systems</span>
                </div>
                <div class="info-item">
                    <span class="label">ID Number</span>
                    <span class="value">EI-2024-0042</span>
                </div>
                <div class="info-item">
                    <span class="label">Clearance</span>
                    <span class="value">Level 3</span>
                </div>
            </div>
            <div class="footer">Protecting Our Future • Est. 2024</div>
        </div>
        <div class="right-column">
            <img src="zephyr.jpg" alt="Avatar" class="avatar">
        </div>
    </div>
</body>
</html>
```