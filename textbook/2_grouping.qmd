---
title: "Grouping"
include-in-header:
  - text: |
      <style>
        .table.dataframe {
          width: auto;
          text-align: right;
        }
      </style>
fig-width: 4
fig-height: 4
resources:
  - data
  - utils.py
---

<!-- Temporarily needed for live coding exercises -->
{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

```{python setup}
#| echo: false
#| output: false

import pandas as pd
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
from IPython.display import HTML

pd.set_option('display.max_rows', 6)

def show_df(df):
    if isinstance(df, ro.vectors.DataFrame):
        with (ro.default_converter + pandas2ri.converter).context():
            df = ro.conversion.get_conversion().rpy2py(df)
    return HTML(df._repr_html_())
```

::: {.callout-note title="Learning outcomes"}
- **Explain** the two main purposes of grouping:
    1. Making direct comparisons between categories/groups, e.g. observations in group A tends to have higher values that those in group B
    2. Avoid making incorrectly generalized conclusions, e.g. there is a general positive trend when all data is looked at together, but grouping reveals that there is actually a negative trend for each group.

- **Evaluate** which grouping strategy is the most suitable in a specific context.
    - Position, color, shape, and size are the most effective to compare exact values between groups since they enable observations to be drawn close to each other in the same chart.
    - Faceting is the most effective when compare overall patterns or trends between groups, since it shows all the values for each group separately from the other groups' values.

- **Apply** grouping strategies using color, size, shape and position to visually distinguish between categories, e.g. `encode(color='category')` and `aes(color=category)`.

- **Apply** the faceting grouping strategy via `facet` and `facet_wrap` method to split data into separate facets/subplots.



:::

## Why grouping matters

So far you have created declarative visualizations by representing them as identical point **marks** on a canvas with encoded x- and y-axis positions. This is the foundation for all the visualizations we will make, but it is rarely sufficient on its own to give a complete picture of the data. In particular, messy real-world data might show overall trends in the datasets, that evaporate when explored more closely. The goal of grouping is to distinguish between groups by basing the visual appearance of points in a chart on the value of categorical variable. Let's see this in action in the following exercise.

::::: {.callout-default .ex-prompt}

In Viridia, historians have been studying the remains from Earth to identify what went wrong and avoid repeating the mistakes of their ancestors. During their research, they uncovered records of a beverage known as "alcohol".

Given the high prevalence of alcohol drinking in many of Earth's nations, the Viridians thought the drink must have had many positive effects and allowed humans to live long and healthy lives. Curious to explore whether this was indeed the case, Viridian historians were excited to uncover a dataset containing the percent of heavy drinkers in each nation together with the average number of years people lived after retirement^[Source: Global Burden of Disease Study 2021 (GBD 2021) Results; Human Mortality Database (2023), United Nations - World Population Prospects (2022) â€“ processed by Our World in Data].

To assess whether nations with a high percentage of heavy drinkers did indeed also tend to live longer lives, the historians created a scatterplot where each point represented a country, the x-axis showing the percentage of heavy alcohol drinkers, and the y-axis showing the average number of years left to live after reaching age 50.

Before viewing what this chart looks like in the solution, draw out (either on paper or in your mind) what you think this chart would look like.

:::: {.callout-default .ex-hint}

Think about what trend would you expect to see in this data? Do you think nations with a high percentage of heavy drinkers have long or short life spans?

::::

::: {.callout-default .ex-solution}

This is the chart that the historians created:

```{python}
#| label: fig-polar
#| echo: false
import altair as alt
import pandas as pd

income_df = pd.read_csv('data/income_lifeexp_alcohol_1.csv')['income_group', 'country', 'percentage_heavy_drinkers', 'life_expectancy_at_50,region']

alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
    tooltip=['country', 'income_group', 'region']
)
```

From this scatter plot, the Viridians observe that nations with a high percentage of heavy drinkers does indeed tend to also have longer lifespans, such great news! Excited about their findings, the historians hurry to find out how to produce this noble alcohol beverage to hopefully introduce it into Viridian society as soon as possible.

:::

::::

:::::


::::: {.callout-default .ex-prompt}

"Not so fast" you caution the Viridian historians.
Your memories of alcohol are dim,
particularly from those nights when you ingested the substance,
but you have a vague recollection of that it is not the health solution
that the Viridians are looking for.
You ask to see the raw data,
something you should always look at before taking any rash decisions.
Confident in their findings,
the historians show you the first few rows of the data in the table below,
and inform you that you can hover over the points
in the chart above to see additional information for each observations.

```python
show_df(income_df)
```

Study the table and the tooltip of the previous chart.
What do you think might be the reason
that countries with a higher percentage of heavy drinkers
also have a higher life expectancy?
Suggest one visual change to the chart
that would help you explore if your suggested reason
could influence the relationship between alcohol consumption and lifespan.

:::: {.callout-default .ex-hint}

Do you think other variables in the dataset could influence alcohol consumption? E.g. the average income of the country or the region of the world where it is located? To see this in the chart could you include some type of grouping according to that column, e.g. shape or color?

::: {.callout-default .ex-solution}

Both the country's income group and region might have an effect on the alcohol consumption and the lifespan. Here, we will explore this for the income group only, and you are free to explore the region on your own. We could change the chart to color each point by its income group:

```{python}
#| echo: false
alt.Chart(income_df).mark_point().encode(
    color='income_group',
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
)
```

Notice how the data points form clusters by income group. Coloring reveals that both national alcoholism levels and life expectancy are correlated with income. <span style="color: #9CCCC8; font-weight: bold">High income</span> countries tend to have longer lifespans and a greater proportion of heavy alcohol drinkers. We see the opposite picture for most <span style="color: #5D84A8; font-weight: bold">low income</span>, where both indicators are lower. 

This could explain the mysterious relationship the historians found between heavy drinkers and life expectancy! It seems like countries that have a higher average income are likely to both have people who drink more and people who live longer. By using color to group the data, we have revealed that income level is a **confounding variable**: it influences both life expectancy and alcohol consumption. If we had data at finer resolution, which contained each individual, we would likely see that they people who drink a lot don't live the longest lives, but we don't have access to that data here.

The insights you have found are sobering news for the Viridian historians,
who are sure to proceed more cautiously in future project.

:::

::::

:::::

Coloring data points is a powerful example of a technique known as **grouping**. The goal of grouping is to distinguish between groups by basing the visual appearance of data points on the value of categorical variable. 

As we have seen with alcohol consumption and life expectancy, grouping has major benefits. It allows us to:

1. **Directly compare** trends and values for distinct groups

2. **Discover patterns** in the data that were previously obscured

3. **Avoid making inaccurate conclusions** about the relationships in our data

To understand these benefits, let's consider Simpson's Paradox. The paradox was not invented by Homer Simpson et al., but rather Edward H. Simpson, a British codebreaker. 

Simpson reported a curious phenomenon where a trend present in several different groups of data disappears when they are combined. 

Below is an illustration of the Simpson's Paradox at play. Notice how the overall dataset does not have a clear direction but when you color by group, both groups exhibit the same negative trend. 

::: {.panel-tabset}

### Overall


```{python}
simpsons_df = pd.read_csv("data/simpsons_paradox_data_l.csv")
alt.Chart(simpsons_df).mark_point().encode(
  x='X',
  y='Y',
)
```

### By group

```{python}
alt.Chart(simpsons_df).mark_point().encode(
  color='Group',
  x='X',
  y='Y',
)
```

:::

In this case, grouping makes the insidious Simpson's Paradox visually unmistakable. This is a prime example of the dual purpose of data visualization. It doesn't just present our data to others; it deepens our understanding of it. 

## Strategies for grouping

The grammar of graphics gives us a convenient syntax for grouping. We simply define the encoding channel that should represent a categorical variable. Color, shape, size and position are the most effective channels for grouping, and they can be easily interchanged:

::: {.panel-tabset}

# Altair
::: {.panel-tabset}

# Color

```python
.encode(color='category_column')
```

# Shape

```python
.encode(shape='category_column')
```

# Size

```python
.encode(size='category_column')
```

# Position

```python
.encode(x='category_column')
```

```python
.encode(y='category_column')
```
:::

# ggplot
::: {.panel-tabset}
# Color

```python
aes(color=category_column)
```

# Shape

```python
aes(shape=category_column)
```

# Size

```python
aes(size=category_column)
```

# Position

```python
aes(x=category_column)
```

```python
aes(y=category_column)
```
:::
:::

The main challenge in applying grouping is understanding which encoding channel best supports the comparisons we want to make. Each grouping strategy has unique strengths and pitfalls, which we shall discuss in detail.

### Color

The human brain can detect color differences with little cognitive effort. Color is a **pre-attentive feature** which means that the brain can tell apart colors even without conscious attention. This is heightened when there is a high contrast, such as between the complimentary colors blue and orange.

This is great news for grouping! By encoding our categorical variable as color, we can leverage the brain's ability to infer groups. For scatterplots, this works best with fewer than eight categories. 

Conveniently, color doesn't alter the layout or structure of the data visualization, so it's an efficient way to compare the exact values of data points between groups.

Let's use color to group our life expectancy data by world region:

::: {.panel-tabset}

# Altair

Here we use `color='region'`:

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
    color='region',
)
```

# ggplot

Here we use `color=region`:
```{r fig.width=8, fig.height=6}
library(readr)
library(ggplot2)
income_df <- read_csv('data/income_lifeexp_alcohol_1.csv', show_col_types = FALSE)

ggplot(income_df, aes(
    x=percentage_heavy_drinkers, 
    y=life_expectancy_at_50, 
    color=region
)) + 
geom_point()
```

:::

Notice how you naturally interpret points of same color as clusters?

But beware... The power of color fades when used irresponsibly. Using   colors that are too similar can blur the difference between groups. The more colors you include, the harder it is to stick to distinct hues.

There is also the challenge of accessibility. Colorblindness affects approximately 8% of men and 0.5% of women globally. The most common variant is deuteranopia. This impairs the ability to distinguish between red and green hues, so designing your data visualization with this in mind is essential. While Altairâ€™s default color palette is designed to be color-blind friendly, ggplotâ€™s is not.

We will learn much more about accessibility in chapter ...including specifics around which colors are safe to use together and which are suitable to represent different data types.

### Shape

Now our visualizations are really taking shape! Shape can be combined with color to provide an additional visual cue. Let's take a look at a classic example: the infamous traffic light. 

Do you think that traffic lights are well designed? At first glance,  they break a major rules of accessibility, using the worst possible colors for people with deuteranopia (red and green). Thankfully, in many countries, traffic lights are encoded using both color and shape. A third encoding channel - position - is then used to establish predictable y-axis positions for both 'Stop' and 'Go' signals. 

![](/img/traffic.png)

Grouping by three encoding channels reinforces the visual contrast and has probably prevented many accidents.

We can use the same syntax to encode both color and shape aesthetics: 

::: {.panel-tabset}

# Altair

Here we use `shape='region'`:

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
    shape='region',
    color='region',
)
```

# ggplot

Here we use `shape=region`:

```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x=percentage_heavy_drinkers, 
    y=life_expectancy_at_50, 
    shape=region,
    color=region
)) + 
geom_point()
```

:::

While this combined approach makes grouping clearer, there are some pitfalls. For instance, line icons limit the total area that can be colored, reducing the impact of color. It is better to use solid shapes when combining shape and color.

Additionally, size matters more than you'd think. Smaller shapes are difficult to distinguish. When plotting a dense scatterplot of small marks, try restricting the number of unique shapes to three or fewer, or consider avoiding using shape altogether.


### Size

Size is often used to represent the magnitude of quantitative data. But it can under limited circumstances be used for grouping. Size has an inherent direction, so it works better for **ordinal** categories - those with a clear order. 

One example is World Bank income level, ranging from low to high. Let's shake up our life expectancy chart, encoding the income level of countries in sub-Saharan Africa as size:

::: {.panel-tabset}

# Altair

Here we use `size='income_group'`:

```{python}
income_df_subset = income_df[income_df['sub-region'].isin(['Sub-Saharan Africa'])]

alt.Chart(income_df_subset).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
    size='income_group',
)
```

# ggplot

Here we use `size=income_group`:

```{r fig.width=8, fig.height=6}

income_df_subset <- subset(income_df, `sub-region` %in% c('Sub-Saharan Africa'))

# Create the scatter plot
ggplot(income_df_subset, aes(
    x=percentage_heavy_drinkers, 
    y=life_expectancy_at_50, 
    size=income_group,
)) + 
geom_point()

```

:::

::: {.callout-caution}
In general, size-based groupings are not very intuitive. Restricting size to four or fewer levels is a good rule of thumb, and for most visualizations grouping by size should be avoided.
:::

### Position

Position is a powerful grouping strategy. It works by encoding our categorical variable as the x or y axis. Each group has its own visual lane, making it easier to compare overall distributions across categories. It  also emphasizes the outliers within each category.

Below, we group on the y-axis to compare heavy alcohol consumption across world regions:

::: {.panel-tabset}

# Altair

Here we use `y='region'`:

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='region',
)
```

# ggplot

Here we use `y=region`:

```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x=percentage_heavy_drinkers, 
    y=region, 
)) + 
geom_point()
```

:::

Notice how easy it is to compare the distributions between regions?

We can even take it one step further. Position can be combined with color to reinforce grouping on one variable or to introduce grouping on a second variable. 

When grouping by two categorical variables, which should you assign to position and which to color? Position is more visually obvious than color. This means that we assign our primary comparison to position and our secondary comparison to color. 

Let's apply this to a real world example.

::::: {.callout-default .ex-prompt}

You are trying to understand how life expectancy varies across income groups globally, and the role world region plays in these differences.

Define the primary and secondary comparisons for this research question.



:::: {.callout-default .ex-solution}

The primary comparison is comparing life expectancy across income groups. The secondary comparison is between world regions.

::::

Now, using the variables `region`, `income_group` and `life_expectancy_at_50`, create a plot that reflects these priorities, showing all countries grouped using position and color. 

::: {.panel-tabset}

# Altair

```{pyodide}
#| setup: true
#| exercise:
#|   - position_alt
#|   - facet_alt
import altair as alt
import pandas as pd
from utils import assert_chart_equal

url = 'data/income_lifeexp_alcohol_1.csv'

```

```{pyodide}
#| exercise: position_alt
income_df = pd.read_csv(url)





# Write code above to create the chart 
```

::: {.callout-default .ex-solution}


```{python}
alt.Chart(income_df).mark_point().encode(
    x='life_expectancy_at_50',
    y='income_group',
    color='region',
)
```

:::

# ggplot

```{webr fig.width=8, fig.height=6}
#| setup: true
#| exercise:
#|   - position_ggplot
#|   - facet_ggplot
library(ggplot2)

url <- 'data/income_lifeexp_alcohol_1.csv'
```

```{webr fig.width=8, fig.height=6}
#| exercise: position_ggplot
income_df <- readr::read_csv(url, show_col_types=FALSE)





# Write code above to create the chart 
```

::: {.callout-default .ex-solution}

You are primarily comparing the `income_group` variable, so it should be grouped by position on either the `x` or `y` axis. The secondary comparison, `region`, should be encoded as color. 
```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x=life_expectancy_at_50, 
    y=income_group, 
    color=region
)) + 
geom_point()
```

:::

:::

:::::

For all of these benefits, there are some drawbacks of grouping by position. For one, it occupies an axis that could have represented a continuous variable. This reduces the information density of your visualization. More worryingly, visually separating each group by position can hide overall trends in the dataset. It also requires significant space.

Lastly, plotting data points along a single axis can lead to  overlap. That's where **jittering** comes to the rescue. Jittering introduces slight variation, or 'jitter', in the position of data points in each lane, making them easier to see. 

::: {.column-margin}

**Jitterbug**

Back in the 1930s, the jitterbug was a lively, often wild, dance style that matched the fast-paced, unpredictable energy of swing music. In data visualization, jittering serves a similar purpose: to add a touch of randomness to points in a plot.

![](/img/640px-Jitterbug_Wolcott_FSA.jpg)

:::

Let's examine how jittering works.

::: {.panel-tabset}

# Altair

In Altair, we create a random calculated variable called `jitter` by appending the `.transform_calculate()` method to our chart. We use our newly created `jitter` variable, encoding it as the `yOffset` of each data point using `yOffset='jitter:Q'`. This shifts the `yOffset` of each point by a random value. 

The `:Q` simply tells Altair that `jitter` is a continuous quantitative variable.

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='region',
    color='region',
    yOffset="jitter:Q"
).transform_calculate(
    jitter="random()"
)
```

# ggplot

In ggplot2, you can achieve the same effect with jittering by using the `position_jitter()` function. Jitter is directly applied to the marks through the position argument within `geom_point()`.

```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x=percentage_heavy_drinkers, 
    y=region, 
    color=region
)) + 
geom_point(position = position_jitter(width = 0, height = 0.2))
```

:::


::: {.callout-caution}
Jittering can be confusing! It can easily be mistaken for a scatterplot with true variation in the underlying data.
:::

## Faceting

Faceting takes the concept of grouping to the next level by generating multiple small charts, each dedicated to a subset of the data. It is particularly effective for highlighting distinct trends and patterns in each subset, as well as identifying extreme values or outliers within groups. And unlike grouping by position, faceting keeps both the x and y axis free for other variables.

Let's check out the syntax:

::: {.panel-tabset}

# Altair

In Altair, faceting by World Bank income group is straightforward. We simply append `.facet('income_group')` to our chart. Additionally, we can control the layout by setting the number of columns using the `columns` argument:

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
).facet(
    'income_group',
    columns=2
)
```

# ggplot

Facetting works via `facet_wrap`. By default it tries to create an even num of cols and rows, rather than putting all plot in one row like Altair. However, you can specify the desired number of columns with the `ncol` argument.


```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x = percentage_heavy_drinkers, 
    y = life_expectancy_at_50
)) +
geom_point() +
facet_wrap(~ income_group, ncol=2)
```

:::

Faceting makes it easy to see the overall shape of the distribution for each income group and how tightly clustered the values are. It also reveals outliers in the Upper Middle Income facet â€“ we can easily spot two countries with a higher percentage of heavy drinkers.

Another advantage is that we can apply additional layers of grouping within each facet. Now its your turn to try this!

::::: {.callout-default .ex-prompt}

Edit this chart to use both faceting and grouping.
Facet by world region (`region`) and group by World Bank income group (`income_group`). 
Ensure that only two facets are shown per row.

::: {.panel-tabset}

# Altair


```{pyodide}
#| exercise: facet_alt
income_df = pd.read_csv(url)

alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
)

```

# ggplot


```{webr fig.width=8, fig.height=6}
#| exercise: facet_ggplot
income_df <- readr::read_csv(url, show_col_types=FALSE)

ggplot(income_df, aes(
    x=percentage_heavy_drinkers, 
    y=life_expectancy_at_50, 
)) + 
geom_point()
```

:::

::: {.callout-default .ex-solution}

::: {.panel-tabset}

# Altair

```{python}
alt.Chart(income_df).mark_point().encode(
    x='percentage_heavy_drinkers',
    y='life_expectancy_at_50',
    color='income_group'
).facet(
    'region',
    columns=2
)
```

# ggplot

```{r fig.width=8, fig.height=6}
ggplot(income_df, aes(
    x = percentage_heavy_drinkers, 
    y = life_expectancy_at_50,
    color=income_group
)) +
geom_point() +
facet_wrap(~ region, ncol=2)
```

:::

:::



:::::

So where does faceting fall short? For one, presenting each group on a separate chart makes it difficult to estimate the overlap between distributions. Its also harder to compare individual values across facets. 

## Deep dive

::: {.callout-default .optional}

:::

## Mission

Viridians pride themselves on being part of the #1 Happiest Colony in the Galaxy. They have won medals and trophies for it. But this year is *extremely competitive*. To make sure they come out on top, Viridians are investigating the history of mental wellbeing on Earth.

::: {.column-margin}

![](/img/medal.jpg){width=200px height=200px}

:::



You will be working with **Grumble Thorax**, a seasoned Happiness Compliance Officer. 

```{=html}
<br>
<div class="ministry-id-card">
    <div class="accent-line"></div>
    <div class="left-column">
        <div class="logo">Ministry of Wellbeing</div>
        <div class="name">Grumble Thorax</div>
        <div class="info">
            <div class="info-item">
                <span class="label">Position</span>
                <span class="value">Happiness Compliance Officer</span>
            </div>
            <div class="info-item">
                <span class="label">Department</span>
                <span class="value">Wellbeing and Flourishing</span>
            </div>
            <div class="info-item">
                <span class="label">ID Number</span>
                <span class="value">EI-2024-2313</span>
            </div>
            <div class="info-item">
                <span class="label">Clearance</span>
                <span class="value">Level 3</span>
            </div>
        </div>
        <div class="footer">Protecting Our Future â€¢ Est. 2024</div>
    </div>
    <div class="right-column">
        <img src="/img/grumble_thorax.jpg" alt="Avatar" class="avatar">
    </div>
</div>
<br>
```

::::: {.callout-default .ex-prompt}

Grumble Thorax has discovered an ancient document called 'Mental State of the World Report 2024'.^[Source: Sapien Labs (2024): https://sapienlabs.org/whats_new/sapien-labs-releases-the-4th-annual-mental-state-of-the-world-report/] Its creators asked hundreds of thousands of Earthlings about their mental wellbeing. Each `age_group` within each `country` received an average mental health quotient score (`MHQ_score`) - the higher number, the better wellbeing. 

We also have a categorical variable for the world `region`.
```{python}
#| echo: false
wellbeing_df = pd.read_csv('data/MH_data_processed_3.csv')

show_df(wellbeing_df)
```

Before you start your analysis, **Grumble Thorax** has some questions for you.
```{r fig.width=8, fig.height=6}
#| echo: false
api = "{{< env URL >}}"
ojs_define(apiUrl = api)
```

```{ojs}
//| echo: false
import {createChatInterface} from "./chat.js"

{

const instructions = "You are Grumble Thorax, a Happiness Compliance Officer. You are black-humoured, sarcastic. You supervising a new worker to analyze the 'Mental State of the World Report', which has the variables `age_group`, mental health score `MHQ_score` and `region` (these are continents not countries, e.g, Africa). Be supportive and help them to answer your question fully and specifically. If they talk about totally unrelated things like countries shut them down and steer them back. Do not provide answers as this is an open ended question more about testing their reasoning (any hypothesis is fine, support it). Once you get a satisfactory answer, end the conversation immediately and ask them to proceed to the next task. Ensure that the user's ideas cover both age groups and regions. Be succinct - are in a phone text convo.";

const first_message = "A new recruit... I can hardly contain my joy. If you're so clever, what trends do you expect to see in the data?";

const chatInterface = createChatInterface({
  apiUrl,
  instructions: instructions,
  firstMessage: first_message,
  bossImage: 'img/grumble_thorax.jpg',
  bossName: 'Grumble Thorax',
});

return html`${chatInterface}`;

}
```


It's time to use everything you've learnt in this chapter. 

**Create a visualization comparing how mental wellbeing varies across age groups within each region. You should use a combination of faceting, position and color.**


::: {.panel-tabset}

# Altair

```{pyodide}
#| setup: true
#| exercise:
#|   - mission_1_alt
#|   - mission_2_alt

import altair as alt
import pandas as pd
from utils import assert_chart_equal

url = 'data/MH_data_processed_3.csv'

```

```{pyodide}
#| exercise: mission_1_alt
wellbeing_df = pd.read_csv(url)





# Write code above to create the chart 
```

:::: {.callout-default .ex-hint}
Faceting isolates each group make it easier to compare values within each group. Which categorical variable are you looking within?



:::: {.callout-default .ex-solution}

```{python}
alt.Chart(wellbeing_df).mark_point().encode(
    y='MHQ_score',
    x='age_group',
    color="age_group"
).facet(
    'region'
)
```

::::

::::


# ggplot

```{webr fig.width=8, fig.height=6}
#| setup: true
#| exercise:
#|   - mission_1_ggplot
#|   - mission_2_ggplot
library(ggplot2)

url <- 'data/MH_data_processed_3.csv'
```

```{webr fig.width=8, fig.height=6}
#| exercise: mission_1_ggplot
wellbeing_df <- readr::read_csv(url, show_col_types=FALSE)





# Write code above to create the chart 
```


:::: {.callout-default .ex-hint}
Faceting isolates each group make it easier to compare values within each group. Which categorical variable are you looking within?


:::: {.callout-default .ex-solution}

```{r fig.width=8, fig.height=6}
#| echo: false

wellbeing_df <- readr::read_csv('data/MH_data_processed_3.csv', show_col_types=FALSE)
```

```{r fig.width=8, fig.height=6}
ggplot(wellbeing_df, aes(
    x = region, 
    y = MHQ_score, 
    color = region)) +
  geom_point() +
  facet_wrap(~ age_group)
```

::::  

::::

:::






**Great work! Now create the opposite visualization, comparing how mental wellbeing varies across regions within each age group.**

::: {.panel-tabset}

# Altair

```{pyodide}
#| exercise: mission_2_alt
wellbeing_df = pd.read_csv(url)





# Write code above to create the chart 
```


:::: {.callout-default .ex-solution}


```{python}
alt.Chart(wellbeing_df).mark_point().encode(
    y='MHQ_score',
    x='region',
    color="region"
).facet(
    'age_group'
)
```

:::: 

# ggplot



```{webr fig.width=8, fig.height=6}
#| exercise: mission_2_ggplot
wellbeing_df <- readr::read_csv(url, show_col_types=FALSE)





# Write code above to create the chart 
```


:::: {.callout-default .ex-solution}


```{r fig.width=8, fig.height=6}

ggplot(wellbeing_df, aes(
    x = region, 
    y = MHQ_score, 
    color = region)) +
  geom_point() +
  facet_wrap(~ age_group)
```

:::: 

:::

**It's time to report your findings back to Grumble Thorax...**

```{ojs}
//| echo: false

{

const instructions = "You are Grumble Thorax, a Happiness Compliance Officer. You are black-humoured, sarcastic. You supervising a new worker who has just analyzed the 'Mental State of the World Report'. You are looking for the following answers: generally mental wellbeing increases as people get older (higher age groups). In younger people Africa seems to have the highest MHQ scores, and in older its the Americas. Europe and Oceania consistently have the lowest across all age groups. Asia is medium-high. Be supportive and help them to answer your question fully and specifically. If they talk about totally unrelated things shut them down and steer them back. Do not provide answers as this is an open ended question more about testing their reasoning (any hypothesis is fine, support it). Use probing questions, do not give the answers away unless they are totally stuck after 3 responses. Once you get a satisfactory answer, end the conversation immediately and tell them their mission is complete and that you actually don't hate them. Say goodbye. Ensure that the user's ideas cover both age groups and regions. Be succinct - are in a phone text convo.";

const first_message = "Oh, look who decided to show up again. Well, spill itâ€”what did you find out?";

const chatInterface = createChatInterface({
  apiUrl,
  instructions: instructions,
  firstMessage: first_message,
  bossImage: 'img/grumble_thorax.jpg',
  bossName: 'Grumble Thorax',
});

return html`${chatInterface}`;

}
```

:::::